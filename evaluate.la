#       There are five registers used specially for evaluating
#       Lossless code. In general they each have a singular purpose but
#       some are also misused between and within the evaluator
#       subroutines to avoid having to spill the general-purpose
#       registers to the stack.
#
#       Accumulator     The result of evaluation, or just `the result'.
#       Arguments       Partially-evaluated list of function arguments.
#       Control-Link    The stack. This register is not misused.
#       Environment     The current run-time environment, also not misused.
#       Expression      The expression or sub-expression being evaluated.
#
#       As well as being used within a subroutine, primarily to
#       spill general-purpose registers so that it can use them,
#       the stack is used between subroutines by pushing an address
#       to return to (eg. obtained with the PEND operator) *after*
#       any data it will need that won't be in other registers.
#
#       To evaluate an expression push the address to return the
#       result to such as !Exit to the stack and fill the Expression
#       register, then start interpretation at or jump to !Evaluate.
#
#       If the expression being evaluated is a symbol the result
#       is the value that symbol is bound to in the environment
#       (LOOKUP) and control returns to the address saved on the
#       stack. This instruction has the public label !Return for
#       use in the frequent operation of popping an address off the
#       stack and jumping to it in a conditional JUMPIF/JUMPNOT
#       instruction.
#
#       If the expression being evaluated is a pair then it denotes
#       a combiner which requires more work, performed by Combine/Start.
#
#       Otherwise if it's not a pair or a symbol the expression
#       evaluates to itself, ie. it's copied straight to the Accumulator.
#
#       (In) Expression: The expression to evaluate
#       (In) Control-Link: ...
#
#       (Return) Accumulator: The evaluated result

!Exit   HALT
!Evaluate
        SYMBOL? tmp,expr
        JUMPNOT tmp,@1f
        LOOKUP  acc,env,expr    Look for the symbol in the Environment.
!Return POP!    ip,clink
1h      PAIR?   tmp,expr
        JUMPIF  tmp,@Combine/Start
        SYNTAX? tmp,expr
        JUMPNOT tmp,@1f
        CAR     acc,expr
        CDR     expr,expr
        LOAD    tmp,'quote
        CMPIS?  tmp,acc,tmp
        JUMPIF  tmp,@1f
        LOAD    tmp,'quasiquote
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@2f
        TRAP    'unimplemented  ...
2h      LOAD    tmp,'unquote
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@2f
        TRAP    'unimplemented  ...
2h      LOAD    tmp,'splice
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@2f
        TRAP    'unimplemented  ...
2h      TRAP    'unimplemented
1h      LOAD    acc,expr        Save the expression in the Accumulator.
        POP!    ip,clink        There is no need to JUMP via !Return; only
;                               in a JUMPIF/JUMPNOT instruction.

#       The first item in a list, or the combiner, determines how
#       a list will be combined (or the sinister half of a pair ---
#       the list need not be proper).
#
#       To determine what the first item in the list is requires
#       another trip through the evaluator before even considering
#       the arguments and this particular trip may itself be part
#       of the process of evaluating the arguments of another a
#       combiner, so before anything else a `frame header' is pushed
#       to the stack consisting of the current Arguments and
#       Environment. Immediately after the remainder of the combination
#       is pushed to the stack followed by a directive to continue
#       with Combine/Dispatch after determining what the combiner is.
#
#       Then the combiner is placed in Expression and control
#       recurses back to !Evaluate to determine how to proceed.
#
#       (In) Argument-List: A list of arguments to a combiner in the process
#                  of being built and into which the result of
#                  evaluating THIS combiner will be placed.
#       (In) Expression: The combination expression (list) being evaluated.
#       (In) Control-Link: ...

Combine/Start
        PUSH!   clink,args      Stack any arguments which are currently
;                               being evaluated in a previous stack frame.
        PUSH!   clink,env       Also stack the current run-time environment.
        CDR     tmp,expr
        PUSH!   clink,tmp       Extract and stack the remainder of the
;                               (uncombined) list.
        PEND    tmp,@Combine/Dispatch
        PUSH!   clink,tmp       Continue from Combine/Dispatch after evaluation.
        CAR     expr,expr       The combiner which determines what to do with
;                               the arguments just saved.
        PEND    ip,@!Evaluate   Recurse into the evaluator.

#       When the evaluator has determined what the combiner is, control
#       reaches Combine/Dispatch. This routine simply jumps to
#       Combine-Primitive, Combine-Closure or the unwritten
#       Combine-Resumption, or raises an error because the object
#       cannot be used to perform combination.
#
#       (In) Accumulator: Combiner (combination's first list item, evaluated)
#       (In) Control-Link: Uncombined-Arguments <Frame>
#
#       (Out) Expression: Combiner

Combine/Dispatch
        LOAD          expr,acc
        PRIMITIVE?    tmp,expr
        JUMPIF        tmp,@Combine-Primitive
        CLOSURE?      tmp,expr
        JUMPIF        tmp,@Combine-Closure
        RESUMPTION?   tmp,expr
        JUMPIF        tmp,@Combine-Primitive
        TRAP          'uncombinable

#       After combination is finally complete and the result is in
#       the Accumulator this routine will restore the in-process
#       Arguments and run-time Environment from the frame header
#       saved in Combine/Start and resume whatever was happening
#       at the time, ascending out of one level of recursion.
#
#       (In) Accumulator: Combined result.
#       (In) Control-Link: <Frame> ...
#
#       (Out) Control-Link:

Combine/Finish
        POP!    env,clink
        POP!    args,clink
        POP!    ip,clink

#       Lossless understands two types of combiner, primitives and
#       closure which are described here. The defining aspect of a
#       closure is its signature, which is a list describing how
#       the evaluator should handle its arguments, known as the
#       argument strategy.

#       Each strategy in the closure's signature describes how to
#       process the source arguments (ie. evaluate them or not) and
#       then bind the result or some run-time evaluator state.

#       Two registers are spilled to the stack releasing them to
#       use in examining the signature/strategy. r0 will hold the
#       remaining strategy list and r1 the binding or strategy
#       label. The source arguments are popped back off the stack
#       and Expression is used to build a list of directives to
#       push onto the stack if the source arguments' syntax is valid.

#       (In) Expression: Closure object
#       (In) Control-Link: Uncombined-Arguments <Frame>

Combine-Closure
        POP!    args,clink      Restore unprocessed arguments.
        PUSH!   clink,expr
        PUSH!   clink,r0
        PUSH!   clink,r1
        SIGNATURE r0,expr
        LOAD    expr,()

#       Here begins the loop to process each strategy in the closure's
#       signature. First the (remaining) signature is checked against
#       nil indicating that there should be no (more) arguments and
#       control moves to Combine-Closure/signature/finish.

#       Each strategy is a list with two items in it: the location
#       to bind to and how that argument should be handled by this
#       evaluator. The most common strategy is `eval' to evaluate
#       an argument in the run-time environment and bind the resulting
#       value in the extended closure environment.

#       The binding location of a closure is a (unique) symbol.

#       (In) Arguments: Uncombined arguments
#       (In) Control-Link: r1 r0 Closure <Frame>
#       (In) Expression: Evaluation queue
#       (In) r0: (Remaining) signature

Combine-Closure/signature/next
        CMPIS?  tmp,r0,()       Finished?
        JUMPIF  tmp,@Combine-Closure/signature/finish
        CAR     acc,r0          Strategy.
        CDR     r0,r0           Next signature.
        CAR     r1,acc          Argument's binding label.
        CDR     acc,acc
        CAR     acc,acc         Strategy label.
        LOAD    tmp,'eval       Check if this strategy is eval, otherwise
;                               continue at Combine-Closure/signature/eval-list?
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@Combine-Closure/signature/eval-list?
        PAIR?   tmp,args        Is the remaining Arguments a pair?
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand

#       To evaluate an argument which will be bound in a closure's
#       run-time environment two directives will be pushed to the
#       stack, here being built up in Expression in reverse. First
#       Combine/Evaluate-Argument will run the argument through
#       !Evaluate then Combine/Append-Argument will append the
#       result to Arguments along with the label it will be bound
#       to when the arguments are all ready.

#       Eventually this will push an iteration of the following
#       sequence to the stack (Control-Link):
#
#           /Evaluate-Argument Argument /Append-Argument Binding
#
#       ... followed by another one (or something more exotic; read
#       on), or the directive to complete the combination (see
#       Combine-Closure/signature/finish).

#       (In) Expression: Evaluation queue
#       (In) Arguments: Unscanned arguments
#       (In) r1: Binding label

1h      PEND    tmp,@Combine/Evaluate-Argument
        CONS    expr,tmp,expr
        CAR     tmp,args
        CONS    expr,tmp,expr
        CDR     args,args
        PEND    tmp,@Combine/Append-Argument
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        PEND    ip,@Combine-Closure/signature/next

#       If the argument strategy wasn't eval the next most familiar
#       is eval-list, which is an instruction to evaluate all of
#       the remaining arguments as the eval strategy does but build
#       them into a list which is bound to a single label, ie. this
#       handles the last label in the dotted-tail of a lambda or let
#       closure.

#       Ordinarily each result will be pushed onto Arguments in a
#       pair that includes its binding location. In this case an
#       empty list is first pushed onto Arguments alone and each
#       result is appended to that. When all of the results have
#       been computed the list is put in the correct order and
#       paired with its binding location.

#       (In) Accumulator: Strategy label
#       (In) Expression: Evaluation queue

Combine-Closure/signature/eval-list?
        LOAD    tmp,'eval-list
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@Combine-Closure/signature/copy?
        PEND    tmp,@Combine/Evaluate-List/Start
        CONS    expr,tmp,expr

#       Similar to the loop for the eval strategy this pushes each
#       remaining argument to Expression along with the directives
#       to handle the result --- Combine/Evaluate-List/Append-Argument.

#       (In) Arguments: Unscanned arguments
#       (In) Expression: (List) evaluation queue

Combine-Closure/signature/eval-list/next
        CMPIS?  tmp,args,()
        JUMPIF  tmp,@Combine-Closure/signature/eval-list/finish
        PAIR?   tmp,args
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand   Improper list
1h      PEND    tmp,@Combine/Evaluate-Argument
        CONS    expr,tmp,expr
        CAR     tmp,args
        CONS    expr,tmp,expr
        CDR     args,args
        PEND    tmp,@Combine/Evaluate-List/Append-Argument
        CONS    expr,tmp,expr
        PEND    ip,@Combine-Closure/signature/eval-list/next

#       When the eval-list strategy has finished scanning the source
#       arguments the final directive which will ready the list for
#       binding is added to Expression.

#       (In) Expression: (List) evaluation queue
#       (In) r1: Binding label

Combine-Closure/signature/eval-list/finish
        PEND    tmp,@Combine/Evaluate-List/Finish
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        PEND    ip,@Combine-Closure/signature/next

#       The eval and eval-list strategies cover the closures that
#       will be encountered most of the time so it'll be helpful
#       to pause here to describe how the Expression register is
#       moved to the stack and how each argument is eventually
#       processed into a result and bound.

#       The first check is to see if anything is left in Arguments
#       not described by the signature, otherwise the arguments
#       were valid so r0 and r1 are restored and the stack is
#       prepared.

#       First, or last after the arguments are ready, Combine/Finish
#       is pushed onto the stack where it can return to the level
#       of recursion begun in Combine/Start with the result of the
#       combination now in the Accumulator.

#       In order to place that result there Combine-Closure/Ready
#       is positioned on the stack so it is reached after processing
#       the arguments is complete and they're ready in Arguments.

#       Before Combine-Closure/Ready come the directives now in
#       Expression. As the source arguments list was scanned in
#       order, the list in Expression is in reverse (ie. the
#       directives for the first argument are at the back of the
#       list). Moving that onto the stack reverses the list again
#       and so this routine ends with the directive to process the
#       first argument on top of the stack with the rest in their
#       natural order.

#       (In) Arguments: unhandled arguments, should be nil.
#       (In) Expression: stack additions in reverse
#       (In) Control-Link: r1 r0 Closure <Frame>

#       This is where the routine started by Combine-Closure (from
#       Combine/Dispatch) finishes and the evaluator begins to
#       execute the plan just built.

#       (Out) Arguments: ()
#       (Out) Expression: ()
#       (Out) Control-Link: (Queue) /Ready Closure /Finish <Frame>

Combine-Closure/signature/finish
        CMPIS?  tmp,args,()     Signature ended with unhandled arguments?
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      POP!    r1,clink        Restore spilled registers.
        POP!    r0,clink
        POP!    acc,clink       Restore the closure.
        PEND    tmp,@Combine/Finish
        PUSH!   clink,tmp
        PUSH!   clink,acc
        PEND    tmp,@Combine-Closure/Ready
        PUSH!   clink,tmp
1h      CMPIS?  tmp,expr,()     Finished?
        JUMPIF  tmp,@1f
        CAR     tmp,expr        Move the next item from Expression.
        PUSH!   clink,tmp
        CDR     expr,expr
        PEND    ip,@1b
1h      POP!    ip,clink        Arguments is now ().

#       In order to evaluate an argument it gets popped off the
#       stack into Expression and control continues with !Evaluate.
#       After evaluation control will reach Combine/Append-Argument
#       below.

#       (In) Arguments: In-progress list of pre-bound arguments
#       (In) Control-Link: Argument /Append-Argument Binding ...

Combine/Evaluate-Argument
        POP!    expr,clink
        PEND    ip,@!Evaluate

#       When an argument has been evaluated its result is in the
#       Accumulator and it's pushed onto Arguments along with the
#       location it's going to be bound to. If an argument isn't
#       being evaluated then it's popped off the stack as in
#       Combine/Evaluate-Argument but straight onto the Accumulator
#       without going through !Evaluate.

#       (In; Append) Accumulator: Evaluated result
#       (In; Append) Control-Link: Binding ...
#       (In; Copy) Control-Link: Argument Binding ...
#
#       (In/Out) Arguments: In-progress list of pre-bound arguments

Combine/Copy-Argument
        POP!    acc,clink
Combine/Append-Argument
        POP!    tmp,clink
        CONS    acc,tmp,acc     Pair the result with its binding location.
        CONS    args,acc,args   Save the pair in Arguments.
        POP!    ip,clink        Keep calm.

#       To bind a (remaining) list of arguments of unknown length to a single variable first
# the list terminator is pushed onto Arguments, without a binding label. This will be added later.

#       After preparing to build a new list control will proceed
#       with either Combine/Evaluate-List/Append-Argument or
#       Combine/Evaluate-List/Finish if there were no arguments in
#       the source expression.

#       (In) Arguments: In-progress list of pre-bound arguments

Combine/Evaluate-List/Start
        CONS    args,(),args
        POP!    ip,clink

#       (In) Accumulator: Next result
#       (In/Out) Arguments: In-progress list of pre-bound arguments
#                           with in-progress list of remaining arguments
#                           at the front

Combine/Evaluate-List/Append-Argument
        CAR     tmp,args
        CONS    acc,acc,tmp
        CDR     args,args
        CONS    args,acc,args
        POP!    ip,clink

#       (In) Arguments: In-progress list of pre-bound arguments
#                       with in-progress list of remaining arguments
#                       at the front
#       (In) Control-Link: Binding Next ...

#       (Out) Arguments: In-progress list of pre-bound arguments
#                        with finished list of remaining arguments
#                        at the front (in reverse)
#       (Out) Control-Link: ...

Combine/Evaluate-List/Finish
        CAR     expr,args
        CDR     args,args
        LOAD    acc,()
1h      CMPIS?  tmp,expr,()
        JUMPIF  tmp,@1f
        CAR     tmp,expr
        CONS    acc,tmp,acc
        CDR     expr,expr
        PEND    ip,@1b
1h      POP!    tmp,clink
        CONS    acc,tmp,acc
        CONS    args,acc,args
        POP!    ip,clink

#       Load closure's environment & expand
#       set bindings from args
#       Load body into expression

#       (In) Arguments: Finished list of pre-bound arguments
#       (In) Environment: Caller's run-time environment
#       (In) Control-Link: Closure <Frame>

Combine-Closure/Ready
        POP!    expr,clink      Restore closure
        ADDRESS acc,expr
        LOAD    ip,acc

#       This is the default address assigned to a closure before
#       it's compiled.

#       (In) Arguments: Finished list of pre-bound arguments
#       (In) Environment: Caller's run-time environment
#       (In) Expression: Closure
#       (In) Control-Link: <Frame>

#       (Out) Environment: Extended closure environment with arguments bound
#       (Out) Expression: Closure body

!Interpret-Closure
        OPEN    env,expr        Closure environment
        EXTEND  env,env
1h      CMPIS?  tmp,args,()
        JUMPIF  tmp,@1f
        CAR     tmp,args
        DEFINE! env,tmp
        CDR     args,args
        PEND    ip,@1b
1h      PUSH!   clink,r0        Prepare to enter !Primitive/do
        BODY    r0,expr         Closure body
        PEND    ip,@!Primitive/do

#       Returning to the remaining closure signature strategies,
#       the copy strategy copies the argument from the source
#       expression as-is without evaluation.

#       Note that the branch through Combine-Closure/Append-Argument
#       is made directly without wasting space for it on the stack
#       as /Copy-Argument does not need to wait for the evaluator to
#       process the argument first.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Unscanned arguments
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

Combine-Closure/signature/copy?
        LOAD    tmp,'copy
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@Combine-Closure/signature/copy-list?
        PAIR?   tmp,args
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      PEND    tmp,@Combine/Copy-Argument
        CONS    expr,tmp,expr
        CAR     tmp,args
        CONS    expr,tmp,expr
        CDR     args,args
        CONS    expr,r1,expr
        PEND    ip,@Combine-Closure/signature/next

#       The copy-list strategy directs the evaluator to bind the
#       remaining source arguments without any further processing
#       at all. This works by duplicating the plain copy process
#       but moving the unscanned arguments into the accumulator and
#       continuing as though it was a regular argument to copy.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Remaining arguments (maybe none)
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

Combine-Closure/signature/copy-list?
        LOAD    tmp,'copy-list
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@Combine-Closure/signature/environment?
        PEND    tmp,@Combine/Copy-Argument
        CONS    expr,tmp,expr
        CONS    expr,args,expr
        CONS    expr,r1,expr
        LOAD    args,()
        PEND    ip,@Combine-Closure/signature/next

#       A closure's strategies describe the arguments which it
#       requires. It may also dictate that additional evaluator
#       state be bound in the closure's extended environment. These
#       strategies must come after all of the copy/eval strategies
#       (of which one of the list strategies, if present, must
#       be last and along); no attempt is made to enforce this here
#       but in the !Primitive/vov routine which creates these
#       extended closures.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Should be ()
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

Combine-Closure/signature/environment?
        LOAD    tmp,'environment
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@Combine-Closure/signature/continuation?
        CMPIS?  tmp,args,()
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      PEND    tmp,@Combine/Copy-Environment
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        PEND    ip,@Combine-Closure/signature/next

#       Capturing the run-time environment is a simple matter of
#       copying it into the Accumulator.

#       (In) Control-Link: Binding ...
#
#       (In/Out) Arguments: In-progress list of pre-bound arguments
#       (Out) Control-Link: ...

Combine/Copy-Environment
        LOAD    acc,env
        PEND    ip,@Combine/Append-Argument

#       The only strategy remaining strategy which Lossless supports
#       is to capture the run-time continuation of the closure's
#       caller although there is scope to implement other strategies
#       by handling the unimplemented feature trap.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Should be ()
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

#       The only argument strategy remaining is a continuation.
Combine-Closure/signature/continuation?
        LOAD    tmp,'environment
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@1f
        TRAP    'unimplemented
1h      CMPIS?  tmp,args,()
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand   Too many arguments.
1h      PEND    tmp,@Combine/Copy-Continuation
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        PEND    ip,@Combine-Closure/signature/next

#       Capturing the run-time continuation is also not supported.

Combine/Copy-Continuation
        TRAP    'unimplemented

#       A primitive works similarly to a closure in most respects
#       except two:

#           Only the eval, copy and copy-list strategies are available.
#
#           The binding location is a number identifying a register.

#       (In) Expression: Primitive object
#       (In) Control-Link: Uncombined-Arguments <Frame>

Combine-Primitive
        POP!    args,clink      Restore unprocessed arguments.
        PUSH!   clink,expr      Save closure object.
        PUSH!   clink,r0        Used for the signature.
        PUSH!   clink,r1        Used for each strategy.
        SIGNATURE r0,expr
        LOAD    expr,()         Prepare a queue of evaluation/copy work.

#       Identical to Combine-Closure/signature/next except for
#       continuing at Combine-Primitive/signature/copy? or
#       Combine-Primitive/signature/next.

#       (Out) Accumulator: Strategy label
#       (Out) r1: Binding label
#
#       (In/Out) Arguments: Unscanned arguments
#       (In/Out) Expression: Evaluation queue

Combine-Primitive/signature/next
        CMPIS?  tmp,r0,()       Finished?
        JUMPIF  tmp,@Combine-Primitive/signature/finish
        CAR     acc,r0          Next formal
        CDR     r0,r0
        CAR     r1,acc          Register `binding', an integer.
        CDR     acc,acc
        CAR     acc,acc         Strategy
        LOAD    tmp,'eval
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@Combine-Primitive/signature/copy?
        PAIR?   tmp,args
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      PEND    tmp,@Combine/Evaluate-Argument
        CONS    expr,tmp,expr
        CAR     tmp,args
        CONS    expr,tmp,expr
        CDR     args,args
        PEND    tmp,@Combine/Append-Argument
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        PEND    ip,@Combine-Primitive/signature/next

#       Also practically identical to Combine-Closure/signature/copy?.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Unscanned arguments
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

Combine-Primitive/signature/copy?
        LOAD    tmp,'copy
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@Combine-Primitive/signature/optional?
        PAIR?   tmp,args
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand   Improper list
1h      PEND    tmp,@Combine/Copy-Argument
        CONS    expr,tmp,expr
        CAR     tmp,args
        CONS    expr,tmp,expr
        CDR     args,args
        CONS    expr,r1,expr
        PEND    ip,@Combine-Primitive/signature/next

#       (In) Accumulator: Strategy label
#       (In) Arguments: Unscanned arguments
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

Combine-Primitive/signature/optional?
        LOAD    tmp,'optional
        CMPIS?  tmp,acc,tmp
        JUMPNOT tmp,@Combine-Primitive/signature/copy-list?

        CMPIS?  tmp,args,()
        JUMPIF  tmp,@2f

        PAIR?   tmp,args
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand

1h      CDR     tmp,args
        CMPIS?  tmp,tmp,()
        JUMPIF  tmp,@2f
        TRAP    'incompatible-operand

2h      PEND    tmp,@Combine/Copy-Argument
        CONS    expr,tmp,expr
        CONS    expr,args,expr
        CONS    expr,r1,expr
        LOAD    args,()

        PEND    ip,@Combine-Primitive/signature/finish

#       The only argument strategy remaining is copy-list which
#       will also always be the last strategy.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Remaining arguments
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label
#
#       (Out) Arguments: ()

Combine-Primitive/signature/copy-list?
        PEND    tmp,@Combine/Copy-Argument
        CONS    expr,tmp,expr
        CONS    expr,args,expr
        CONS    expr,r1,expr
        LOAD    args,()

#       (In) Arguments: Should be ()
#       (In) Expression: Evaluation queue
#       (In) Control-Link: r1 r0 Closure <Frame>
#
#       (Out) Arguments: ()
#       (Out) Expression: ()
#       (Out) Control-Link: (Queue) /Ready Closure /Finish <Frame>

Combine-Primitive/signature/finish
        CMPIS?  tmp,args,()
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      LOAD    args,expr
        POP!    r1,clink
        POP!    r0,clink
        POP!    expr,clink
        PEND    tmp,@Combine/Finish
        PUSH!   clink,tmp
        PUSH!   clink,expr
        PEND    tmp,@Combine-Primitive/Ready
        PUSH!   clink,tmp
1h      CMPIS?  tmp,args,()
        JUMPIF  tmp,@1f
        CAR     tmp,args
        PUSH!   clink,tmp
        CDR     args,args
        PEND    ip,@1b
1h      POP!    ip,clink        Args is now ()

#       The primitives are defined such that the last argument,
#       first in Arguments which has been built in reverse, has as
#       the number identifying the highest used register as its
#       binding location. Unless there are no arguments and no
#       registers to spill. There is no need to check the remaining
#       arguments' binding register.
#
#       The primitive is responsible for restoring the spilled
#       registers before returning control to the caller.
#
#       This assembly language's addressing syntax could do with
#       an addressing mode to calculate the jump-in point to start
#       from rather than iterating over each choice in turn.

Combine-Primitive/Ready
        POP!    acc,clink       Retrieve the closure.
        ADDRESS acc,acc         Closure's start address.
        CMPIS?  tmp,args,()
        JUMPIF  tmp,acc         If there are no arguments proceed directly
;                               to the primitive implementation.
        CAR     expr,args       First argument.
        CAR     tmp,expr        First register number.
        CMPIS?  tmp,tmp,0
        JUMPIF  tmp,@0f
        CAR     tmp,expr        There's no spare space to store the register
;                               number! Extract it again.
        CMPIS?  tmp,tmp,1
        JUMPIF  tmp,@1f
        CAR     tmp,expr
        CMPIS?  tmp,tmp,2
        JUMPIF  tmp,@2f
        CAR     tmp,expr
        CMPIS?  tmp,tmp,3
        JUMPIF  tmp,@3f
        TRAP    'lossless-error No primitive has more than 4 arguments; this
;                               instruction `is' unreachable.
0h      PUSH!   clink,r0
        CDR     r0,expr         The argument, discarding the bindling location.
        CDR     args,args       The remaining arguments list.
        LOAD    ip,acc          Jump into the primitive.
1h      PUSH!   clink,r0
        PUSH!   clink,r1
        CDR     r1,expr
        CDR     args,args
        CAR     expr,args       Next argument pair.
        CDR     r0,expr
        CDR     args,args
        LOAD    ip,acc
2h      PUSH!   clink,r0        Repeats...
        PUSH!   clink,r1
        PUSH!   clink,r2
        CDR     r2,expr
        CDR     args,args
        CAR     expr,args
        CDR     r1,expr
        CDR     args,args
        CAR     expr,args
        CDR     r0,expr
        CDR     args,args
        LOAD    ip,acc
3h      PUSH!   clink,r0        Repeats...
        PUSH!   clink,r1
        PUSH!   clink,r2
        PUSH!   clink,r3
        CDR     r3,expr
        CDR     args,args
        CAR     expr,args
        CDR     r2,expr
        CDR     args,args
        CAR     expr,args
        CDR     r1,expr
        CDR     args,args
        CAR     expr,args
        CDR     r0,expr
        CDR     args,args
        LOAD    ip,acc

######## End of the evaluator.

#       Symbols in the root environment are bound to primitives,
#       becoming `operators'. As described above the evaluator is
#       directed to an address to perform the primitive operation
#       after loading its arguments into registers. Restoring the
#       prior values of the registers and returning to the caller
#       is a very common operation and so a common set of routines
#       to return from another function is defined here for general
#       use.

!Primitive.Default
        TRAP    'unimplemented

!Restore/r7     POP!    r7,clink
!Restore/r6     POP!    r6,clink
!Restore/r5     POP!    r5,clink
!Restore/r4     POP!    r4,clink
!Restore/r3     POP!    r3,clink
!Restore/r2     POP!    r2,clink
!Restore/r1     POP!    r1,clink
!Restore/r0     POP!    r0,clink
                POP!    ip,clink

#       Some routines spill higher registers and leave lower-valued
#       registers alone, such as when a routine shares registers
#       with a routine which it calls.

!Restore/r7-1   POP!    r7,clink
!Restore/r6-1   POP!    r6,clink
!Restore/r5-1   POP!    r5,clink
!Restore/r4-1   POP!    r4,clink
!Restore/r3-1   POP!    r3,clink
!Restore/r2-1   POP!    r2,clink
!Restore/r1-1   POP!    r1,clink
                POP!    ip,clink
!Restore/r7-2   POP!    r7,clink
!Restore/r6-2   POP!    r6,clink
!Restore/r5-2   POP!    r5,clink
!Restore/r4-2   POP!    r4,clink
!Restore/r3-2   POP!    r3,clink
!Restore/r2-2   POP!    r2,clink
                POP!    ip,clink
!Restore/r7-3   POP!    r7,clink
!Restore/r6-3   POP!    r6,clink
!Restore/r5-3   POP!    r5,clink
!Restore/r4-3   POP!    r4,clink
!Restore/r3-3   POP!    r3,clink
                POP!    ip,clink
!Restore/r7-4   POP!    r7,clink
!Restore/r6-4   POP!    r6,clink
!Restore/r5-4   POP!    r5,clink
!Restore/r4-4   POP!    r4,clink
                POP!    ip,clink
!Restore/r7-5   POP!    r7,clink
!Restore/r6-5   POP!    r6,clink
!Restore/r5-5   POP!    r5,clink
                POP!    ip,clink
!Restore/r7-6   POP!    r7,clink
!Restore/r6-6   POP!    r6,clink
                POP!    ip,clink

#       The first pair of primitives which will be defined are
#       lambda and vov for building closures. You'd expect `if' or
#       something even more fundamental to come first but for a
#       machine which is built on exactly the concepts of numbers
#       and conditional branching, it's surprising how far you can
#       get without either.
#
#       The lambda primitive receives two arguments which are both
#       unevaluated and therefore need to be validated.
#
#       A valid lambda formals list is a list of unique symbols;
#       the list may be proper or improper provided the dotted tail
#       is also a symbol.
#
#       A closure is the same whether from lambda or vov. While
#       validating the lambda formals a signature is created to
#       match the formals expected by vov. They then share the same
#       code to validate the body and finish.
#
#       Registers r1 to r4 are spilled to the stack while processing
#       the formals list. The final validated signature is built
#       in r4 while r1 to r3 are spare space for the validation.
#
#       (In) Control-Link: r1 r0 ...
#       (In) r0: formals (unvalidated)
#       (In) r1: body (unvalidated)
#
#       (Out) Control-Link: r4 r3 r2 body r1 r0 ...
#       (Out) r2: (eval)
#       (Out) r3: Hashtable of binding labels
#       (Out) r4: Budding signature

!Primitive/lambda
        PUSH!   clink,r1        Spill the body; holds the next label.
        PUSH!   clink,r2        Common tail of all evaluating arguments.
        PUSH!   clink,r3        Hashtable of discovered binding labels.
        PUSH!   clink,r4        Compiled formals.
        LOAD    r4,()
        LOAD    r2,'eval
        CONS    r2,r2,()        (eval)
        TABLE   r3,0

#       Each time around the loop the remainder of the list is
#       checked to see if it's really a symbol indicating that
#       closure is variadic and should consume and evaluate all
#       remaining arguments.
#
#       Otherwise if the next label is unique a new strategy is
#       created for the binding and included in the signature in r4.
#
#       (In) r0: (Remaining) formals
#       (In) r2: (eval)
#       (In) r3: Hashtable of binding labels
#       (In) r4: Budding signature

Primitive/lambda/validate-formals/next
        CMPIS?  tmp,r0,()       Finished?
        JUMPIF  tmp,@Primitive/lambda/validate-formals/finish
        SYMBOL? tmp,r0          Is the (remaining) list really a symbol?
        JUMPIF  tmp,@Primitive/lambda/validate-formals/consume
        PAIR?   tmp,r0          Is the remaining list list-like?
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r1,r0           Next binding label.
        SYMBOL? tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      EXISTS? tmp,r3,r1       Check that this label is unique.
        JUMPNOT tmp,@1f
        TRAP    'conflicted-binding
1h      CONS    tmp,r1,r1
        DEFINE! r3,tmp          Record that this label was used.
        CONS    tmp,r1,r2       Create a new signature strategy for this
;                               binding.
        CONS    r4,tmp,r4       Include the strategy in the signature.
        CDR     r0,r0           Next formal.
        PEND    ip,@Primitive/lambda/validate-formals/next

#       If the lambda formals was a single symbol, or an improper
#       list with a symbol in the dotted tail position, the signature
#       is completed with a strategy to evaluate and consume all
#       remaining arguments. The binding is checked for uniqness
#       but there's no need to record it in r3 which is about to
#       be discarded.
#
#       (In) r0: Binding label
#       (In) r3: Hashtable of binding labels
#       (In) r4: Budding signature

Primitive/lambda/validate-formals/consume
        EXISTS? tmp,r3,r0
        JUMPNOT tmp,@1f
        TRAP    'conflicted-binding
1h      LOAD    r2,'eval-list
        CONS    r2,r2,()
        CONS    tmp,r0,r2
        CONS    r4,tmp,r4
        PEND    ip,@Primitive/lambda/validate-formals/finish

#       After validating the lambda formals a signature representing
#       them has been constructed in r4 in reverse which is copied
#       in the correct order into r0. The spilled registers are
#       restored and control proceeds with Primitive/vov/validate-body
#       to construct the closure.
#
#       (In) Control-Link: r4 r3 r2 r1 ...
#       (In) r4: Reverse signature

#       (Out) Control-Link: ...
#       (Out) r0: Valid signature
#       (Out) r1: Body (unvalidated)

Primitive/lambda/validate-formals/finish
        LOAD    r0,()
1h      CMPIS?  tmp,r4,()
        JUMPIF  tmp,@1f
        CAR     tmp,r4
        CONS    r0,tmp,r0
        CDR     r4,r4
        PEND    ip,@1b
1h      POP!    r4,clink
        POP!    r3,clink
        POP!    r2,clink
        POP!    r1,clink
        PEND    ip,@Primitive/vov/validate-body

#       A vov expression creates a closure with a richer possible
#       signature than the strategies available to a lambda expression.
#       In addition to merely evaluating each argument an `operative'
#       closure can receive the arguments without evaluating them
#       or various kinds of run-time state.
#
#       The formals passed to vov precisely match the signature of
#       the closure that will be created and so validation is just
#       validation without having to process the list like lambda
#       does. The lambda primitive replaces its formals in r0 with
#       a signature compatible with this routine which is why they
#       are able to share the final steps in Primitive/vov/validate-body.
#
#       The formals list as passed and the body are both spilled
#       along with the other three registers this routine needs;
#       they will be used as-is after the work to validate them is
#       discarded.
#
#       r3 and r4 hold a hashtable which records the formals (r3) or
#       state (r4) which have been identified. r2 is used for
#       additional working space.
#
#       (In) Control-Link: ...
#       (In) r0: Unvalidated formals
#       (In) r1: Unvalidated closure body
#
#       (Out) Control-Link: r4 r3 r2 r1 r0 ...
#       (Out) r3: hashtable of identified binding labels.
#       (Out) r4: hashtable of identified state requests.

!Primitive/vov
        PUSH!   clink,r0        Walking along the formals list
        PUSH!   clink,r1        Next formal list
        PUSH!   clink,r2        Working space
        PUSH!   clink,r3
        PUSH!   clink,r4
        TABLE   r3,0            Collected formal labels
        TABLE   r4,0            Collected state requests
        PEND    ip,@Primitive/vov/validate-formals/first

#       With a valid formals signature in r0 validating the body
#       is simply a matter of ensuring it's a proper list.
#
#       TODO: watch out for self-referential lists --- tortoise & hare.
#
#       (In) Control-Link: ...
#       (In) r0: Formals (validated)
#       (In) r1: Body (unvalidated)

Primitive/vov/validate-body
        CMPIS?  tmp,r1,()
        JUMPIF  tmp,@3f
        LOAD    acc,r1
1h      PAIR?   tmp,acc         Looks like a list so far?
        JUMPIF  tmp,@2f
        TRAP    'incompatible-operand
2h      CDR     acc,acc         Remaining instructions.
        CMPIS?  tmp,acc,()      Finished?
        JUMPNOT tmp,@1b
3h      CLOSURE acc,r0,r1       Close over processed/validated formals &
;                               validated body.
        PEND    ip,@!Restore/r1

#       After validating the formals the original list is restored
#       along with the body now ready for its own validation.
#
#       (In) Control-Link: r4 r3 r2 r1 r0 ...
#
#       (Out) Control-Link: ...
#       (Out) r0: Formals (original list, now validated)
#       (Out) r1: Body (unvalidated)

Primitive/vov/validate-formals/finish
        POP!    r4,clink
        POP!    r3,clink
        POP!    r2,clink
        POP!    r1,clink
        POP!    r0,clink        Restore formals as passed
        PEND    ip,@Primitive/vov/validate-body

#       If scanning reaches the end of the formals list then it was
#       valid otherwise control continues with the next.
#
#       (In) r0: (Remaining) unvalidated formals

Primitive/vov/validate-formals/next
        CDR     r0,r0
Primitive/vov/validate-formals/first
        CMPIS?  tmp,r0,()
        JUMPIF  tmp,@Primitive/vov/validate-formals/finish

#       Following on from Primitive/vov/validate-formals/next, here
#       each individual formal is validated. The formals passed to
#       the vov primitive are the same as the signature the final
#       closure will have, namely a list of lists, each inner list
#       of two items: the formal label and argument strategy.
#
#       Any strategy other than plain eval or copy indicates the
#       end of any more copying or evaluating strategies and so
#       control continues with an alternate but similar algorithm
#       starting with Primitive/vov/validate-formals/next%final.
#
#       (In) r0: Remaining unvalidated formals
#       (In) r3: Hashtable containing all binding labels seen
#       (In) r4: Hashtable containing all state requests seen

Primitive/vov/validate-formals/continue
        PAIR?   tmp,r0          Does the (next) formal item continue a list?
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r1,r0           Next formal; should also be list.
        PAIR?   tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r2,r1           Binding label, should be unique symbol.
        SYMBOL? tmp,r2
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      EXISTS? tmp,r3,r2       See if the binding label has been used already.
        JUMPNOT tmp,@1f
        TRAP    'conflicted-binding
1h      CONS    tmp,r2,r2       Create a record of this label.
        DEFINE! r3,tmp
        CDR     r2,r1           The argument strategy, should be a list of one.
        PAIR?   tmp,r2
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CDR     tmp,r2
        CMPIS?  tmp,tmp,()
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r2,r2           The argument strategy.
        LOAD    tmp,'eval
        CMPIS?  tmp,r2,tmp
        JUMPIF  tmp,@Primitive/vov/validate-formals/next
        LOAD    tmp,'copy
        CMPIS?  tmp,r2,tmp
        JUMPIF  tmp,@Primitive/vov/validate-formals/next
        LOAD    tmp,'eval-list
        CMPIS?  tmp,r2,tmp
        JUMPIF  tmp,@Primitive/vov/validate-formals/next%final
        LOAD    tmp,'copy-list
        CMPIS?  tmp,r2,tmp
        JUMPIF  tmp,@Primitive/vov/validate-formals/next%final
        LOAD    tmp,'environment
        CMPIS?  tmp,r2,tmp
        JUMPNOT tmp,@2f
        EXISTS? tmp,r4,r2       Has the environment been requested already?
        JUMPNOT tmp,@1f
        TRAP    'incompatible-operand
1h      CONS    tmp,r2,r2
        DEFINE! r4,tmp          ... it has now.
        PEND    ip,@Primitive/vov/validate-formals/next%final
2h      LOAD    tmp,'continuation
        CMPIS?  tmp,r2,tmp
        JUMPNOT tmp,@2f
        EXISTS? tmp,r4,r2       Requested continuation already?
        JUMPNOT tmp,@1f
2h      TRAP    'incompatible-operand
1h      CONS    tmp,r2,r2
        DEFINE! r4,tmp          Record this request.
        PEND    ip,@Primitive/vov/validate-formals/next%final

#       This is a copy of Primitive/vov/validate-formals/next &
#       Primitive/vov/validate-formals/continue for use when the
#       copying and evaluation strategies are no longer permitted
#       in a valid formals signature.
#
#       (In) r0: Remaining unvalidated formals
#       (In) r3: Hashtable containing all binding labels seen
#       (In) r4: Hashtable containing all state requests seen
#
#       Possible improvement: store #t in r4 until positional formals
#       have finished, then replace it with a hashtable and test
#       for that before validating each formal. Copy pasta for now.
#
Primitive/vov/validate-formals/next%final
        CDR     r0,r0
        CMPIS?  tmp,r0,()
        JUMPIF  tmp,@Primitive/vov/validate-formals/finish
Primitive/vov/validate-formals/continue%final
1h      PAIR?   tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r1,r0           Formal.
        PAIR?   tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r2,r1           Label.
        SYMBOL? tmp,r2
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      EXISTS? tmp,r3,r2
        JUMPNOT tmp,@1f
        TRAP    'conflicted-binding
1h      CONS    tmp,r2,r2
        DEFINE! r3,tmp          Record this label.
        CDR     r2,r1           (Strategy).
        PAIR?   tmp,r2
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CDR     tmp,r2
        CMPIS?  tmp,tmp,()
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r2,r2           Strategy.
        LOAD    tmp,'environment
        CMPIS?  tmp,r2,tmp
        JUMPNOT tmp,@2f
        EXISTS? tmp,r4,r2
        JUMPNOT tmp,@1f
        TRAP    'incompatible-operand
1h      CONS    tmp,r2,r2
        DEFINE! r4,tmp          Record this request.
        PEND    ip,@Primitive/vov/validate-formals/next%final
2h      LOAD    tmp,'continuation
        CMPIS?  tmp,r2,tmp
        JUMPNOT tmp,@2f
        EXISTS? tmp,r4,r2
        JUMPNOT tmp,@1f
2h      TRAP    'incompatible-operand
1h      CONS    tmp,r2,r2
        DEFINE! r4,tmp          Record this request.
        PEND    ip,@Primitive/vov/validate-formals/next%final

!Primitive/do
        PEND    acc,@Primitive/do/next
        CMPIS?  tmp,r0,()
        JUMPNOT tmp,@1f
        LOAD    acc,#VOID
        PEND    ip,@!Restore/r0
        LOAD    args,()
1h      PAIR?   tmp,r0
        JUMPIF  tmp,@2f
        CMPIS?  tmp,r0,()
        JUMPIF  tmp,@3f
        TRAP    'incompatible-operand
2h      CONS    args,acc,args
        CAR     tmp,r0
        CONS    args,tmp,args
        CDR     r0,r0
        PEND    ip,@1b
#
#       Finished processing the list, move & reverse it onto the stack.
#
3h      POP!    r0,clink
1h      CAR     tmp,args
        PUSH!   clink,tmp
        CDR     args,args
        CAR     tmp,args
        PUSH!   clink,tmp
        CDR     args,args
        CMPIS?  tmp,args,()
        JUMPNOT tmp,@1b
        POP!    tmp,clink       Discard first branch directive.
Primitive/do/next
        POP!    expr,clink
        PEND    ip,@!Evaluate

#       (In) Control-Link: r2 r1 r0 ...
#       (In) r0: Environment
#       (In) r1: Label or label & closure formals
#       (In) r2: Value or body of lambda expression
#
!Primitive/set!
        PEND    tmp,@Primitive/define!/set!
        PUSH!   clink,tmp
        PEND    ip,@Primitive/define!/imp
!Primitive/define!
        PEND    tmp,@Primitive/define!/define!
        PUSH!   clink,tmp
Primitive/define!/imp
        ENVIRONMENT? tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      SYMBOL? tmp,r1
        JUMPNOT tmp,@Primitive/define!/lambda
        CMPIS?  tmp,r2,()
        JUMPNOT tmp,@1f
        TRAP    'incompatible-operand
1h      CDR     tmp,r2
        CMPIS?  tmp,tmp,()
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     expr,r2
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@!Evaluate
1h      ENVIRONMENT? tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CONS    r1,r1,acc
        POP!    ip,clink
Primitive/define!/define!
        DEFINE! r0,r1
        PEND    ip,@!Restore/r2
Primitive/define!/set!
        REPLACE! r0,r1
        PEND    ip,@!Restore/r2

#       (In) Control-Link: P/d r2 r1 r0 ...
#       (In) r0: Environment
#       (In) r1: Label or label & closure formals
#       (In) r2: Value or body of lambda expression

Primitive/define!/lambda
        PEND    tmp,@Primitive/define!/lambda/continue
        PUSH!   clink,tmp
        PUSH!   clink,r0        Save environment
        CAR     tmp,r1
        PUSH!   clink,tmp       Save label
        CDR     r0,r1           Formals
        LOAD    r1,r2           Body
        PEND    ip,@!Primitive/lambda

Primitive/define!/lambda/continue
1h      CONS    r1,r1,acc
        POP!    ip,clink

#       (In) Control-Link: r1 r0 ...
#       (In) r0: expression
#       (In) r1: Empty list or of environment
#
!Primitive/eval
        CMPIS?  tmp,r1,()
        JUMPNOT tmp,@1f
        LOAD    expr,r0
        PEND    tmp,@!Restore/r1
        PUSH!   clink,tmp
        PEND    ip,@!Evaluate
1h      CAR     expr,r1
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@!Evaluate
1h      ENVIRONMENT? tmp,acc
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      PUSH!   clink,env
        LOAD    env,acc
        LOAD    expr,r0
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@!Evaluate
1h      POP!    env,clink
        PEND    ip,@!Restore/r1

#       (In) Control-Link: r1 r0 ...
#       (In) r0: condition
#       (In) r1: consequent
#       (In) r2: () or list of alternate
!Primitive/if
        CMPIS?  tmp,r2,()
        JUMPNOT tmp,@1f
        LOAD    r2,#VOID
        PEND    ip,@2f
1h      CAR     r2,r2
2h      CMPIS?  tmp,r0,#f
        JUMPIF  tmp,@1f
        LOAD    expr,r1         Consequent
        PEND    ip,@2f
1h      LOAD    expr,r2         Alternate
2h      PEND    tmp,@!Restore/r2
        PUSH!   clink,tmp
        PEND    ip,@!Evaluate

!Primitive/current-environment
        LOAD    acc,env
        POP!    ip,clink

!Primitive/root-environment
        LOAD    acc,root
        POP!    ip,clink

!Primitive/quote
        LOAD    acc,r0
        PEND    ip,@!Restore/r0

########

!Primitive/record?
        RECORD? acc,r0,r0
        PEND    ip,@!Restore/r0

!Primitive/record%instance?
        RECORD? acc,r0,()
        JUMPNOT acc,@1f
        LOAD    acc,#f
        PEND    ip,@!Restore/r0
1h      RECORD? acc,r0,r0
        PEND    ip,@!Restore/r0

!Primitive/record%template?
        RECORD? acc,r0,()
        PEND    ip,@!Restore/r0

!Primitive/record/instance-of?
        RECORD? tmp,r0,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      RECORD? tmp,r0,()
        JUMPIF  tmp,@1f
        TEMPLATE r0,r0
1h      RECORD? acc,r1,r0
        PEND    ip,@!Restore/r0

#       (new-record <unique-label> ...)
#
!Primitive/new-record
        CMPIS?  tmp,r0,()
        JUMPNOT tmp,@1f
        TRAP    'incompatible-operand
1h      PAIR?   tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      PUSH!   clink,r1
        PUSH!   clink,r2
        TABLE   r1,1
        LOAD    r2,0
Primitive/new-record/next
        PAIR?   tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     acc,r0
        SYMBOL? tmp,acc
        JUMPIF  tmp,@1f
1h      TRAP    'incompatible-operand
        EXISTS? tmp,r1,acc
        JUMPNOT tmp,@1f
        TRAP    'incompatible-operand     conflicted-binding?
1h      CONS    acc,acc,r2
        DEFINE! r1,acc
        ADD     r2,r2,1
        CDR     r0,r0
        CMPIS?  tmp,r0,()
        JUMPNOT tmp,@Primitive/new-record/next
        RECORD  acc,r1
        PEND    ip,@!Restore/r2

#       (new-instance <record>)
#
!Primitive/new-instance
        RECORD? tmp,r0,r0       Instance or template?
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      RECORD  acc,r0
        PEND    ip,@!Restore/r0

!Primitive/record/length
        RECORD? tmp,r0,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      LENGTH  acc,r0
        PEND    ip,@!Restore/r0

#       (record/ref <record> <label>)
!Primitive/record/ref
        PEND    tmp,@!Restore/r1
        PUSH!   clink,tmp
Primitive/record/ref/imp
        RECORD? tmp,r0,()       Template?
        JUMPNOT tmp,@1f
        TRAP    'incompatible-operand
1h      RECORD? tmp,r0,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand

        INTEGER? tmp,r1
        JUMPIF  tmp,@2f
        SYMBOL? tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      LOOKUP  r1,r0,r1
        INTEGER? tmp,r1
        JUMPIF  tmp,@3f
        TRAP    'incompatible-operand

2h      CMPGE?  tmp,r1,0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      LENGTH  tmp,r0
        CMPLT?  tmp,r1,tmp
        JUMPNOT tmp,@3f
        TRAP    'incompatible-operand

3h      REF     acc,r0,r1
        POP!    ip,clink

!Primitive/record/set!
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/record/ref/imp
1h      SET!    r0,r1,r2
        PEND    ip,@!Restore/r2

!Primitive/record/template
        RECORD? tmp,r0,()
        JUMPIF  tmp,@2f
        RECORD? tmp,r0,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      TEMPLATE r0,r0
2h      LOAD    acc,r0
        PEND    ip,@!Restore/r0

########

!Primitive/boolean?
        CMPIS?  acc,r0,#f
        JUMPIF  acc,@1f
        CMPIS?  acc,r0,#t
1h      PEND    ip,@!Restore/r0
!Primitive/false?
        CMPIS?  acc,r0,#f
        PEND    ip,@!Restore/r0
!Primitive/integer?
        INTEGER? acc,r0
        PEND    ip,@!Restore/r0
!Primitive/null?
        CMPIS?  acc,r0,()
        PEND    ip,@!Restore/r0
!Primitive/pair?
        PAIR?   acc,r0
        PEND    ip,@!Restore/r0
!Primitive/segment?
        SEGMENT? acc,r0
        PEND    ip,@!Restore/r0
!Primitive/symbol?
        SYMBOL? acc,r0
        PEND    ip,@!Restore/r0
!Primitive/true?
        CMPIS?  acc,r0,#t
        PEND    ip,@!Restore/r0
!Primitive/void?
        CMPIS?  acc,r0,#VOID
        PEND    ip,@!Restore/r0

!Primitive/is?
        CMPIS?  acc,r0,r1
        PEND    ip,@!Restore/r1

1h      TRAP    'incompatible-operand
!Primitive/cons
        CONS    acc,r0,r1
        PEND    ip,@!Restore/r1
!Primitive/car
        PAIR?   acc,r0
        JUMPNOT acc,@1b
        CAR     acc,r0
        PEND    ip,@!Restore/r0
!Primitive/cdr
        PAIR?   acc,r0
        JUMPNOT acc,@1b
        CDR     acc,r0
        PEND    ip,@!Restore/r0

1h      TRAP    'incompatible-operand
!Primitive/symbol/key
        SYMBOL? acc,r0
        JUMPNOT acc,@1b
#       SLO     acc,'symbol/key
        POP!    ip,clink
!Primitive/symbol/segment
        SYMBOL? acc,r0
        JUMPNOT acc,@1b
#       SLO     acc,'symbol/segment     Read-only
        POP!    ip,clink

#       r0: length
#       r1: alignment
1h      TRAP    'incompatible-operand
!Primitive/new-segment
        CMPLE?  tmp,r0,0
        JUMPIF  tmp,@1b
        CMPLE?  tmp,r1,0
        JUMPIF  tmp,@1b
#       SLO     acc,'new-segment
        POP!    ip,clink

1h      TRAP    'incompatible-operand
!Primitive/segment/resize!
        SEGMENT? tmp,r0
        JUMPNOT tmp,@1b
        CMPLE?  tmp,r1,0
        JUMPIF  tmp,@1b
#       SLO     acc,'segment/resize!
        POP!    ip,clink

1h      TRAP    'incompatible-operand
!Primitive/segment/length
        SEGMENT? tmp,r0
        JUMPNOT tmp,@1b
#       SLO     acc,'segment/length
        POP!    ip,clink

1h      POP!    r4,clink
2h      POP!    r3,clink
        TRAP    'incompatible-operand
!Primitive/segment->symbol
        PEND    tmp,@3f
        PUSH!   clink,tmp
        PEND    ip,@!Primitive/segment/length
3h      PUSH!   clink,r3        Prepare to clobber r3
        LOAD    r3,acc          Segment length
        CMPGE?  tmp,r1,0
        JUMPNOT tmp,@2b         !(off >= 0)?
        CMPGE?  tmp,r1,r3
        JUMPIF  tmp,@2b         off >= max?
        CMPGE?  tmp,r2,0
        JUMPNOT tmp,@2b         !(length >= 0)?
        PUSH!   clink,r4        Prepare to clobber r4
        ADD     r4,r1,r2
        CMPLE?  tmp,r4,r3
        JUMPIF  tmp,@1b         (off + length >= max)?
        POP!    r4,clink        Restore clobbered registers.
        POP!    r3,clink
#       SLO     acc,'segment->symbol
        POP!    ip,clink

########

!Primitive/array?
        ARRAY?  acc,0
        PEND    ip,@!Restore/r0

#       r0: length
#       r1: filler
!Primitive/new-array
        INTEGER? tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CMPGE?  tmp,r0,0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      ARRAY   acc,r0,r1
        PEND    ip,@!Restore/r1

#       r0: array
#       r1: new length
#       r2: new filler
!Primitive/array/resize!
        ARRAY?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      INTEGER? tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CMPGE?  tmp,r0,0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      RESIZE! r0,r1,r2
        PEND    ip,@!Restore/r2

!Primitive/array/length
        ARRAY?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      LENGTH  acc,r0
        PEND    ip,@!Restore/r0

#       r0: array
#       r1: index
!Primitive/array/ref
        PEND    tmp,@Primitive/array/ref/imp
        PUSH!   clink,tmp

Primitive/array/ref/check
        ARRAY?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand

1h      INTEGER? tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand

1h      CMPGE?  tmp,r1,0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand

1h      LENGTH  tmp,r0
        CMPLT?  tmp,r1,tmp
        JUMPIF  tmp,@1f
        TRAP    'out-of-bounds
1h      POP!    ip,clink

Primitive/array/ref/imp
        REF     acc,r0,r1
        PEND    ip,@!Restore/r1

!Primitive/array/set!
        PEND    tmp,@Primitive/array/set!/imp
        PUSH!   clink,tmp
        PEND    ip,@Primitive/array/ref/check
Primitive/array/set!/imp
        SET!    r0,r1,r2
        PEND    ip,@!Restore/r1

########

!Primitive/hashtable?
        TABLE?  acc,r0
        PEND    ip,@!Restore/r0

!Primitive/new-hashtable
        INTEGER? tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CMPGE?  tmp,r0,0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      TABLE   acc,r0
        PEND    ip,@!Restore/r0

!Primitive/hashtable/blocked
        TABLE?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      BLOCKED acc,r0
        PEND    ip,@!Restore/r0

#       r0: hashtable
#       r1: label
#       r2: value
#
!Primitive/hashtable/define!
        TABLE?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      SYMBOL? tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CONS    tmp,r1,r2
        DEFINE! r0,tmp
        PEND    ip,@!Restore/r2

!Primitive/hashtable/erase!
        TABLE?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      SYMBOL? tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CMPIS?  tmp,r0,#f
        JUMPIF  tmp,@1f
        CMPIS?  tmp,r0,#t
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      ERASE!  r0,r1,r2
        PEND    ip,@!Restore/r2

#       r0: hashtable
#       r1: label
#
!Primitive/hashtable/exists?
        TABLE?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      SYMBOL? tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      EXISTS? acc,r0,r1
        PEND    ip,@!Restore/r2

!Primitive/hashtable/free
        TABLE?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      FREE    acc,r0
        PEND    ip,@!Restore/r0

!Primitive/hashtable/length
        TABLE?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      LENGTH  acc,r0
        PEND    ip,@!Restore/r0

!Primitive/hashtable/ref
        TABLE?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      SYMBOL? tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      LOOKUP  acc,r0,r1
        PEND    ip,@!Restore/r2

!Primitive/hashtable/set!
        TABLE?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      SYMBOL? tmp,r1
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      CONS    tmp,r1,r2
1h      REPLACE! r0,tmp
        PEND    ip,@!Restore/r2

!Primitive/hashtable/used
        TABLE?  tmp,r0
        JUMPIF  tmp,@1f
        TRAP    'incompatible-operand
1h      LENGTH  acc,r0
        FREE    tmp,r0
        SUB     acc,acc,tmp
        BLOCKED tmp,r0
        SUB     acc,acc,tmp
        PEND    ip,@!Restore/r0

########

!Primitive/+
        ADD     acc,r0,r1
        PEND    ip,@!Restore/r1
!Primitive/-
        SUB     acc,r0,r1
        PEND    ip,@!Restore/r1
!Primitive/*
        MUL     acc,r0,r1
        PEND    ip,@!Restore/r1






Primitive/read-expression/terminator?
        CMPEQ?  acc,r3,#x28     (
        JUMPIF  acc,@1f
        CMPEQ?  acc,r3,#x29     )
        JUMPIF  acc,@1f
Primitive/read-expression/space?
        CMPEQ?  acc,r3,#x20     Space
        JUMPIF  acc,@1f
        CMPEQ?  acc,r3,#x0a     Line Feed
        JUMPIF  acc,@1f
        CMPEQ?  acc,r3,#x09     Horizontal Tab
1h      POP!    ip,clink

Primitive/read-expression/digit?
        CMPGE?  acc,r3,#x30     0
        JUMPNOT acc,@1f
        CMPLE?  acc,r3,#x39     9
1h      POP!    ip,clink

Primitive/read-expression/printable?
        CMPGT?  acc,r3,#x20     Control codes & space
        JUMPNOT acc,@1f
        LOAD    tmp,#x7f        Delete & Non-ASCII
        CMPLT?  acc,r3,tmp
1h      POP!    ip,clink

#       These characters will become unforbidden as their feature
#       is implemented.
Primitive/read-expression/unimplemented-or-forbidden?
        LOAD    tmp,#x7b        {
        CMPEQ?  acc,r3,tmp
        JUMPIF  acc,@1f
        LOAD    tmp,#x7d        }
        CMPEQ?  acc,r3,tmp
        JUMPIF  acc,@1f
        LOAD    tmp,#x5b        [
        CMPEQ?  acc,r3,tmp
        JUMPIF  acc,@1f
        LOAD    tmp,#x5d        ]
        CMPEQ?  acc,r3,tmp
        JUMPIF  acc,@1f
        CMPEQ?  acc,r3,#x24     $
        JUMPIF  acc,@1f
        CMPEQ?  acc,r3,#x22     "
        JUMPIF  acc,@1f
        CMPEQ?  acc,r3,#x3b     ;
        JUMPIF  acc,@1f
        LOAD    tmp,#x7c        |
        CMPEQ?  acc,r3,tmp
        JUMPIF  acc,@1f
Primitive/read-expression/forbidden?
        LOAD    tmp,#x5c        \
        CMPEQ?  acc,r3,tmp
1h      POP!    ip,clink


#       (In) r0: segment
#       (In) r1: position
#       (In) r2: length
#
#       (Out) Accumulator: Attempt to read past the end?
#       (Out) r3: (if not) the byte.
#
Primitive/read-expression/source-byte
        CMPGE?  acc,r1,r2
        JUMPIF  acc,@1f
        PEEK    r3,r0,r1
1h      POP!    ip,clink

#       (In) r0: segment
#       (In) r1: start/offset
#
#       (Out) Accumulator: Object
#       (Out) r0: segment
#       (Out) r1: consumed
#
#       -: r2: segment length
#       -: r3: byte, result type
#       -: r4: base offset, object
#       -: r5: negative?
#       -: r6: numeric sum
#       -: r7: numeric multiplier
#
!Primitive/read-expression
        SEGMENT? tmp,r0
        JUMPIF  tmp,@1f
0h      TRAP    'incompatible-operand
1h      INTEGER? tmp,r1
        JUMPNOT tmp,@0b
        CMPLT?  tmp,r1,0
        JUMPIF  tmp,@0b
        LENGTH  acc,r0
        CMPGE?  tmp,r1,acc
        JUMPIF  tmp,@0b
        PUSH!   clink,r2
        PUSH!   clink,r3
        PUSH!   clink,r4
        PUSH!   clink,r5
        PUSH!   clink,r6
        PUSH!   clink,r7
        LOAD    r2,acc
        PEND    tmp,@Primitive/read-expression/finished
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/imp

#       (In)    Accumulator: Expression
#       (In)    r1: offset
#       (In)    r3: type of expression
#                   close
#                   dot
#                   eof
#                   finish
#
Primitive/read-expression/finished
        LOAD    tmp,'object
        CMPIS?  tmp,r3,tmp
        JUMPNOT tmp,@1f
        PEND    ip,@!Restore/r7-2
1h      LOAD    tmp,'close
        CMPIS?  tmp,r3,tmp
        JUMPNOT tmp,@1f
        TRAP    'unopened-list
1h      LOAD    tmp,'dot
        CMPIS?  tmp,r3,tmp
        JUMPNOT tmp,@1f
        TRAP    'non-list-tail
#       Is eof
1h      TRAP    'missing

#       This is the heart of the read function.
#

Primitive/read-expression/back-up
        SUB     r1,r1,1
        POP!    ip,clink        Probably to the next instruction.
Primitive/read-expression/next
        ADD     r1,r1,1
Primitive/read-expression/imp
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPNOT acc,@1f
        LOAD    r3,'eof
        POP!    ip,clink
1h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/space?
1h      JUMPIF  acc,@Primitive/read-expression/next
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/printable?
1h      JUMPIF  acc,@1f
        TRAP    'unprintable
1h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/unimplemented-or-forbidden?
1h      JUMPNOT acc,@1f
        TRAP    'syntax-error
#
#       In r3 is a printable, non-space character that's valid to
#       begin an expression.
1h      CMPIS?  tmp,r3,#x28     (
        JUMPIF  tmp,@Primitive/read-expression/begin-list
1h      CMPIS?  tmp,r3,#x2e     .
        JUMPNOT tmp,@1f
        PEND    ip,@Primitive/read-expression/dot
1h      CMPIS?  tmp,r3,#x29     )
        JUMPNOT tmp,@1f
        LOAD    acc,()
        LOAD    r3,'close
        POP!    ip,clink
1h      CMPIS?  tmp,r3,#x27     '
        JUMPNOT tmp,@1f
        LOAD    r3,'quote
        PEND    ip,@Primitive/read-expression/quote
1h      LOAD    tmp,#x60        `
        CMPIS?  tmp,r3,tmp
        JUMPNOT tmp,@1f
        LOAD    r3,'quasiquote
        PEND    ip,@Primitive/read-expression/quote
1h      CMPEQ?  tmp,r3,#x2c     ,
        JUMPNOT tmp,@1f
        LOAD    r3,'unquote
        PEND    ip,@Primitive/read-expression/quote
1h      CMPIS?  tmp,r3,#x23     #
        JUMPIF  tmp,@Primitive/read-expression/special
1h      CMPIS?  tmp,r3,#x2d     -; offset is not incremented yet
        JUMPNOT tmp,@1f
        LOAD    r5,#t
        PEND    ip,@Primitive/read-expression/possible-number
1h      CMPIS?  tmp,r3,#x2b     +; offset is not incremented yet
        JUMPNOT tmp,@1f
        LOAD    r5,#f
        PEND    ip,@Primitive/read-expression/possible-number
1h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/digit?
1h      JUMPIF  acc,@Primitive/read-expression/number
        PEND    ip,@Primitive/read-expression/symbol

#       dot followed by terminator: 'dot into r3, JUMP =clink
#       dot followed by [^.], syntax error
#       dotdot followed by [^.], syntax error
#       dotdotdot followed by !terminator: syntax error
#       otherwise symbol
#
#       r1 is at the first .

Primitive/read-expression/dot
        LOAD    r4,r1
        ADD     r1,r1,1
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPNOT acc,@1f
9h      LOAD    r3,'dot
        POP!    ip,clink
1h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/terminator?
1h      JUMPIF  acc,@9b
        CMPIS?  tmp,r3,#x2e     .
        JUMPIF  tmp,@1f
        TRAP    'syntax-error   "." followed by not "."

1h      ADD     r1,r1,1         ".." so far
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPNOT acc,@1f
        TRAP    'syntax-error   ".." exactly, eof
1h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/terminator?
1h      JUMPNOT acc,@1f
        TRAP    'syntax-error   ".." exactly, terminated in-band
1h      CMPIS?  tmp,r3,#x2e     .
        JUMPIF  tmp,@1f
        TRAP    'syntax-error   ".." followed by not "."

1h      ADD     r1,r1,1         "..." so far
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPNOT acc,@1f
        PEND    ip,@Primitive/read-expression/symbol/finish
1h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/terminator?
1h      JUMPNOT acc,@1f         "..." exactly, terminated in-band
        PEND    tmp,@Primitive/read-expression/back-up
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/symbol/finish
1h      TRAP    'syntax-error   "..." unterminated

Primitive/read-expression/quote
        PUSH!   clink,r3        Quoting method
        PEND    tmp,@Primitive/read-expression/quote/continue
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/next
Primitive/read-expression/quote/continue
        POP!    tmp,clink
        SYNTAX  acc,tmp,acc
        POP!    ip,clink

#       This is the other heart which recursively reads expressions
#       to form them into lists.
#
Primitive/read-expression/begin-list
        PUSH!   clink,()
        PEND    tmp,@Primitive/read-expression/continue-list
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/next

#       (In)    Accumulator: Expression
#       (In)    r1: offset
#       (In)    r3: type of expression
#
Primitive/read-expression/continue-list
        LOAD    tmp,'object
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@1f
        LOAD    tmp,'close
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/close-list
        LOAD    tmp,'dot
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/list-tail
        TRAP    'unclosed-list  From eof.
1h      POP!    tmp,clink
        CONS    tmp,acc,tmp
        PUSH!   clink,tmp
        PEND    tmp,@Primitive/read-expression/continue-list
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/next

#       The close symbol has placed () in the accumulator, when
#       reached from Primitive/read-expression/list-tail/finish
#       that is replaced with the dotted tail.
#
Primitive/read-expression/close-list
        POP!    r3,clink
1h      CMPIS?  tmp,r3,()
        JUMPIF  tmp,@2f
        CAR     tmp,r3
        CONS    acc,tmp,acc
        CDR     r3,r3
        PEND    ip,@1b
2h      LOAD    r3,'object
        POP!    ip,clink

#       Expects two more 'expressions'; a finished expression
#       followed by close.
#
Primitive/read-expression/list-tail
        REF     tmp,clink,0
        REF     tmp,clink,tmp
        CMPIS?  tmp,tmp,()
        JUMPNOT tmp,@1f
        TRAP    'non-list-tail
1h      PEND    tmp,@Primitive/read-expression/list-tail/expression
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/next

Primitive/read-expression/list-tail/expression
        LOAD    tmp,'object
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@2f
        LOAD    tmp,'dot
        CMPIS?  tmp,r3,tmp
        JUMPNOT tmp,@1f
        TRAP    'double-tail
1h      LOAD    tmp,'close
        CMPIS?  tmp,r3,tmp
        JUMPNOT tmp,@1f
        TRAP    'unterminated-tail
1h      TRAP    'unclosed-list  Is EOF.
2h      PUSH!   clink,acc
        PEND    tmp,@Primitive/read-expression/list-tail/finish
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/next

Primitive/read-expression/list-tail/finish
        LOAD    tmp,'close
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@2f
        LOAD    tmp,'dot
        CMPIS?  tmp,r3,tmp
        JUMPNOT tmp,@1f
        TRAP    'double-tail
1h      LOAD    tmp,'eof
        CMPIS?  tmp,r3,tmp
        JUMPNOT tmp,@1f
        TRAP    'unclosed-list
1h      TRAP    'tail-mid-list
2h      POP!    acc,clink       Restore the dotted tail.
        PEND    ip,@Primitive/read-expression/close-list












#       It's all just boring text parsing from here.
#
#       (In)    r0: segment
#       (In)    r1: first byte offset
#
Primitive/read-expression/symbol
        LOAD    r4,r1
Primitive/read-expression/symbol/next
        ADD     r1,r1,1
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPIF  acc,@Primitive/read-expression/symbol/finish ... if #eof.
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/terminator?
1h      JUMPNOT acc,@1f
        PEND    tmp,@Primitive/read-expression/back-up
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/symbol/finish
1h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/printable?
1h      JUMPIF  acc,@2f
        TRAP    'unprintable
2h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/forbidden?
1h      JUMPNOT acc,@Primitive/read-expression/symbol/next
        TRAP    'syntax-error

#       (In)    r0: segment
#       (In)    r1: terminal offset
#       (In)    r4: starting offset

#       (Out)   Accumulator: symbol
#       (Out)   r0: segment
#       (Out)   r1: terminal offset
#       (Out)   r2: segment length
#       (Out)   r3: 'object

Primitive/read-expression/symbol/finish
        SUB     r3,r1,r4        Symbol length
        SYMBOL  r0,r4,r3
        LOAD    r3,'object
        POP!    ip,clink

#       (In)    r0: segment
#       (In)    r1: starting (sign) offset
#
#       -       r4: negate?

Primitive/read-expression/special
        ADD     r1,r1,1
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPNOT acc,@2f        if !#eof.
        TRAP    'syntax-error
2h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/printable?
1h      JUMPIF  acc,@2f
        TRAP    'unprintable
2h      LOAD    tmp,#x46        F
        CMPIS?  tmp,r3,tmp
        JUMPNOT tmp,@1f
2h      LOAD    r4,#f
        PEND    ip,@Primitive/read-expression/boolean
1h      LOAD    tmp,#x66        f
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@2b
        LOAD    tmp,#x54        T; use r4 to save a few ops
        CMPIS?  r4,r3,tmp
        JUMPIF  r4,@Primitive/read-expression/boolean
        LOAD    tmp,#x74        t
        CMPIS?  r4,r3,tmp
        JUMPIF  r4,@Primitive/read-expression/boolean
        LOAD    tmp,#x5c        \
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/rune
        PEND    ip,@Primitive/read-expression/special-number

Primitive/read-expression/boolean
3h      ADD     r1,r1,1
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPIF  acc,@2f         if #eof.
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/terminator?
1h      JUMPNOT acc,@3f
        SUB     r1,r1,1
        PEND    ip,@2f
3h      TRAP    'syntax-error
2h      LOAD    acc,r4
        LOAD    r3,'object
        POP!    ip,clink

#       A sign byte has been encountered (r5 is true if it's `-'),
#       r1 has not advanced.

Primitive/read-expression/possible-number
        LOAD    r4,r1           Save the sign byte offset.
        ADD     r1,r1,1
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPIF  acc,@Primitive/read-expression/symbol/finish ... if #eof.
        PEND    tmp,@1f         Look for a digit starting a signed
;                               base 10 number.
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/digit?
1h      JUMPIF  acc,@Primitive/read-expression/number
        CMPIS?  acc,r3,#x23     #
        JUMPNOT acc,@1f
        ADD     r1,r1,1         Found a signed number; move to the base
;                               indicator character.
        PEND    tmp,@Primitive/read-expression/special-number/imp
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      LOAD    r1,r4           Move back to [-+].
        PEND    ip,@Primitive/read-expression/symbol/next

Primitive/read-expression/special-number
        LOAD    r5,#f
        PEND    ip,@1f
Primitive/read-expression/special-number/imp
        JUMPNOT acc,@1f        COMEFROM @Primitive/read-expression/source-byte
        TRAP    'syntax-error   [-+]#
1h      LOAD    tmp,#x42        B
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/binary
        LOAD    tmp,#x62        b
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/binary
        LOAD    tmp,#x64        D
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/decimal
        LOAD    tmp,#x64        d
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/decimal
        LOAD    tmp,#x6f        O
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/octal
        LOAD    tmp,#x6f        o
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/octal
        LOAD    tmp,#x58        X
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/hex
        LOAD    tmp,#x78        x
        CMPIS?  tmp,r3,tmp
        JUMPIF  tmp,@Primitive/read-expression/hex
        TRAP    'syntax-error

Primitive/read-expression/binary
        LOAD    r7,2
        LOAD    r6,0
        ADD     r4,r1,1
        PEND    ip,@Primitive/read-expression/number/next
Primitive/read-expression/octal
        LOAD    r7,8
        LOAD    r6,0
        ADD     r4,r1,1
        PEND    ip,@Primitive/read-expression/number/next
Primitive/read-expression/decimal
        LOAD    r7,10
        LOAD    r6,0
        ADD     r4,r1,1
        PEND    ip,@Primitive/read-expression/number/next

Primitive/read-expression/number
        LOAD    r7,10
        SUB     r6,r3,#x30      0
        LOAD    r5,#f           Negate?
        LOAD    r4,r1
Primitive/read-expression/number/next
        ADD     r1,r1,1
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPNOT acc,@1f        ... unless eof.
2h      CMPEQ?  acc,r1,r4
        JUMPNOT acc,@Primitive/read-expression/number/finish
        TRAP    'syntax-error
1h      PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/terminator?
1h      JUMPIF  acc,@2b
        CMPGE?  tmp,r3,#x30     0
        JUMPIF  tmp,@3f         Possibly a digit.
2h      PEND    tmp,@1f         Wrong, but how?
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/printable?
1h      JUMPIF  acc,@1f
        TRAP    'unprintable
1h      TRAP    'syntax-error
3h      SUB     r3,r3,#x30      0
        CMPLT?  tmp,r3,r7       Small enough?
        JUMPIF  tmp,@1f
        ADD     r3,r3,#x30
        PEND    ip,@2b
1h      MUL     r6,r6,r7
        ADD     r6,r6,r3
        PEND    ip,@Primitive/read-expression/number/next

Primitive/read-expression/hex
        LOAD    r6,0
        ADD     r1,r1,1
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPNOT acc,@1f
        TRAP    'syntax-error
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/terminator?
1h      JUMPNOT acc,@1f
        TRAP    'syntax-error
Primitive/read-expression/hex/digit
1h      LOAD    tmp,#x66        f
        CMPLE?  acc,r3,tmp
        JUMPIF  acc,@1f
        TRAP    'syntax-error
1h      LOAD    acc,#x61        a
        CMPGE?  tmp,r3,acc
        JUMPNOT tmp,@1f
        SUB     r4,r3,acc
        PEND    ip,@2f

1h      LOAD    tmp,#x46        F
        CMPLE?  tmp,r3,tmp
        JUMPIF  tmp,@1f
        TRAP    'syntax-error
1h      LOAD    acc,#x41        A
        CMPGE?  tmp,r3,acc
        JUMPIF  tmp,@1f
        SUB     r4,r3,acc
        PEND    ip,@2f

1h      CMPLE?  tmp,r3,#x39     9
        JUMPIF  tmp,@1f
        TRAP    'syntax-error
1h      LOAD    acc,#x30        0; put in the accumulator to match the letters' algorithm.
        CMPGE?  tmp,r3,acc
        JUMPIF  tmp,@1f
        TRAP    'syntax-error
2h      MUL     r6,r6,#x10
        SUB     r4,r3,acc
        ADD     r6,r6,r4
        ADD     r1,r1,1
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/source-byte
1h      JUMPIF  acc,@Primitive/read-expression/number/finish
        PEND    tmp,@1f
        PUSH!   clink,tmp
        PEND    ip,@Primitive/read-expression/terminator?
1h      JUMPIF  acc,@Primitive/read-expression/number/finish
        PEND    ip,@Primitive/read-expression/hex/digit

Primitive/read-expression/number/finish
        JUMPNOT r5,@1f          Negate?
        SUB     r6,0,r6
1h      LOAD    acc,r6          Number
        LOAD    r3,'object
        PEND    ip,@Primitive/read-expression/back-up

Primitive/read-expression/rune
        TRAP    'unimplemented
