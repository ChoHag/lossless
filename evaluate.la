#       There are five registers used specially for evaluating
#       Lossless code. In general they each have a singular purpose but
#       some are also misused between and within the evaluator
#       subroutines to avoid having to spill the general-purpose
#       registers to the stack.
#
#       Accumulator     The result of evaluation, or just `the result'.
#       Arguments       Partially-evaluated list of function arguments.
#       Control-Link    The stack. This register is not misused.
#       Environment     The current run-time environment, also not misused.
#       Expression      The expression or sub-expression being evaluated.
#
#       As well as being used within a subroutine, primarily to
#       spill general-purpose registers so that it can use them,
#       the stack is used between subroutines by pushing an address
#       to return to (eg. obtained with the PEND operator) *after*
#       any data it will need that won't be in other registers.
#
#       To evaluate an expression push the address to return the
#       result to such as !Exit to the stack and fill the Expression
#       register, then start interpretation at or jump to !Evaluate.
#
#       If the expression being evaluated is a symbol the result
#       is the value that symbol is bound to in the environment
#       (LOOKUP) and control returns to the address saved on the
#       stack. This instruction has the public label !Return for
#       use in the frequent operation of popping an address off the
#       stack and jumping to it in a conditional BRANCH instruction.
#
#       If the expression being evaluated is a pair then it denotes
#       a combiner which requires more work, performed by Combine/Start.
#
#       Otherwise if it's not a pair or a symbol the expression
#       evaluates to itself, ie. it's copied straight to the Accumulator.
#
#       (In) Expression: The expression to evaluate
#       (In) Control-Link: ...
#
#       (Return) Accumulator: The evaluated result

!Evaluate
        SYMBOL? tmp,expr
        BRANCH  =tmp,@1f
        LOOKUP  acc,env,expr    Look for the symbol in the Environment.
!Return JUMP    =clink
1h      PAIR?   tmp,expr
        BRANCH  tmp,@Combine/Start
        LOAD    acc,expr        Save the expression in the Accumulator.
        JUMP    =clink          There is no need to JUMP via !Return; only
;                               in a BRANCH instruction.
!Exit   HALT

#       The first item in a list, or the combiner, determines how
#       a list will be combined (or the sinister half of a pair ---
#       the list need not be proper).
#
#       To determine what the first item in the list is requires
#       another trip through the evaluator before even considering
#       the arguments and this particular trip may itself be part
#       of the process of evaluating the arguments of another a
#       combiner, so before anything else a `frame header' is pushed
#       to the stack consisting of the current Arguments and
#       Environment. Immediately after the remainder of the combination
#       is pushed to the stack followed by a directive to continue
#       with Combine/Dispatch after determining what the combiner is.
#
#       Then the combiner is placed in Expression and control
#       recurses back to !Evaluate to determine how to proceed.
#
#       (In) Argument-List: A list of arguments to a combiner in the process
#                  of being built and into which the result of
#                  evaluating THIS combiner will be placed.
#       (In) Expression: The combination expression (list) being evaluated.
#       (In) Control-Link: ...

Combine/Start
        LOAD    clink,args      Stack any arguments which are currently
;                               being evaluated in a previous stack frame.
        LOAD    clink,env       Also stack the current run-time environment.
        CDR     clink,expr      Extract and stack the remainder of the
;                               (uncombined) list.
        PEND    clink,@Combine/Dispatch   Continue from Combine/Dispatch
;                               after evaluation.
        CAR     expr,expr       The combiner which determines what to do with
;                               the arguments just saved.
        JUMP    @!Evaluate      Recurse into the evaluator.

#       When the evaluator has determined what the combiner is, control
#       reaches Combine/Dispatch. This routine simply jumps to
#       Combine-Primitive, Combine-Closure or the unwritten
#       Combine-Resumption, or raises an error because the object
#       cannot be used to perform combination.
#
#       (In) Accumulator: Combiner (combination's first list item, evaluated)
#       (In) Control-Link: Uncombined-Arguments <Frame>
#
#       (Out) Expression: Combiner

Combine/Dispatch
        LOAD          expr,acc
        PRIMITIVE?    tmp,expr
        BRANCH        tmp,@Combine-Primitive
        CLOSURE?      tmp,expr
        BRANCH        tmp,@Combine-Closure
        RESUMPTION?   tmp,expr
        BRANCH        tmp,@Combine-Primitive
        TRAP          'uncombinable

#       After combination is finally complete and the result is in
#       the Accumulator this routine will restore the in-process
#       Arguments and run-time Environment from the frame header
#       saved in Combine/Start and resume whatever was happening
#       at the time, ascending out of one level of recursion.
#
#       (In) Accumulator: Combined result.
#       (In) Control-Link: <Frame> ...
#
#       (Out) Control-Link:

Combine/Finish
        LOAD    env,=clink
        LOAD    args,=clink
        JUMP    =clink

#       Lossless understands two types of combiner, primitives and
#       closure which are described here. The defining aspect of a
#       closure is its signature, which is a list describing how
#       the evaluator should handle its arguments, known as the
#       argument strategy.

#       Each strategy in the closure's signature describes how to
#       process the source arguments (ie. evaluate them or not) and
#       then bind the result or some run-time evaluator state.

#       Two registers are spilled to the stack releasing them to
#       use in examining the signature/strategy. r0 will hold the
#       remaining strategy list and r1 the binding or strategy
#       label. The source arguments are popped back off the stack
#       and Expression is used to build a list of directives to
#       push onto the stack if the source arguments' syntax is valid.

#       (In) Expression: Closure object
#       (In) Control-Link: Uncombined-Arguments <Frame>

Combine-Closure
        LOAD    args,=clink     Restore unprocessed arguments.
        LOAD    clink,expr
        LOAD    clink,r0
        LOAD    clink,r1
        SIGNATURE r0,expr
        LOAD    expr,()

#       Here begins the loop to process each strategy in the closure's
#       signature. First the (remaining) signature is checked against
#       nil indicating that there should be no (more) arguments and
#       control moves to Combine-Closure/signature/finish.

#       Each strategy is a list with two items in it: the location
#       to bind to and how that argument should be handled by this
#       evaluator. The most common strategy is `eval' to evaluate
#       an argument in the run-time environment and bind the resulting
#       value in the extended closure environment.

#       The binding location of a closure is a (unique) symbol.

#       (In) Arguments: Uncombined arguments
#       (In) Control-Link: r1 r0 Closure <Frame>
#       (In) Expression: Evaluation queue
#       (In) r0: (Remaining) signature

Combine-Closure/signature/next
        CMPIS?  tmp,r0,()       Finished?
        BRANCH  tmp,@Combine-Closure/signature/finish
        CAR     acc,r0          Strategy.
        CDR     r0,r0           Next signature.
        CAR     r1,acc          Argument's binding label.
        CDR     acc,acc
        CAR     acc,acc         Strategy label.
        LOAD    tmp,'eval       Check if this strategy is eval, otherwise
;                               continue at Combine-Closure/signature/eval-list?
        CMPIS?  tmp,acc,tmp
        BRANCH  =tmp,@Combine-Closure/signature/eval-list?
        PAIR?   tmp,args        Is the remaining Arguments a pair?
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand

#       To evaluate an argument which will be bound in a closure's
#       run-time environment two directives will be pushed to the
#       stack, here being built up in Expression in reverse. First
#       Combine/Evaluate-Argument will run the argument through
#       !Evaluate then Combine/Append-Argument will append the
#       result to Arguments along with the label it will be bound
#       to when the arguments are all ready.

#       Eventually this will push an iteration of the following
#       sequence to the stack (Control-Link):
#
#           /Evaluate-Argument Argument /Append-Argument Binding
#
#       ... followed by another one (or something more exotic; read
#       on), or the directive to complete the combination (see
#       Combine-Closure/signature/finish).

#       (In) Expression: Evaluation queue
#       (In) Arguments: Unscanned arguments
#       (In) r1: Binding label

1h      PEND    tmp,@Combine/Evaluate-Argument
        CONS    expr,tmp,expr
        CONS    expr,=args,expr
        PEND    tmp,@Combine/Append-Argument
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        JUMP    @Combine-Closure/signature/next

#       If the argument strategy wasn't eval the next most familiar
#       is eval-list, which is an instruction to evaluate all of
#       the remaining arguments as the eval strategy does but build
#       them into a list which is bound to a single label, ie. this
#       handles the last label in the dotted-tail of a lambda or let
#       closure.

#       Ordinarily each result will be pushed onto Arguments in a
#       pair that includes its binding location. In this case an
#       empty list is first pushed onto Arguments alone and each
#       result is appended to that. When all of the results have
#       been computed the list is put in the correct order and
#       paired with its binding location.

#       (In) Accumulator: Strategy label
#       (In) Expression: Evaluation queue

Combine-Closure/signature/eval-list?
        LOAD    tmp,'eval-list
        CMPIS?  tmp,acc,tmp
        BRANCH  =tmp,@Combine-Closure/signature/copy?
        PEND    tmp,@Combine/Evaluate-List/Start
        CONS    expr,tmp,expr

#       Similar to the loop for the eval strategy this pushes each
#       remaining argument to Expression along with the directives
#       to handle the result --- Combine/Evaluate-List/Append-Argument.

#       (In) Arguments: Unscanned arguments
#       (In) Expression: (List) evaluation queue

Combine-Closure/signature/eval-list/next
        CMPIS?  tmp,args,()
        BRANCH  tmp,@Combine-Closure/signature/eval-list/finish
        PAIR?   tmp,args
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand   Improper list
1h      PEND    tmp,@Combine/Evaluate-Argument
        CONS    expr,tmp,expr
        CONS    expr,=args,expr
        PEND    tmp,@Combine/Evaluate-List/Append-Argument
        CONS    expr,tmp,expr
        JUMP    @Combine-Closure/signature/eval-list/next

#       When the eval-list strategy has finished scanning the source
#       arguments the final directive which will ready the list for
#       binding is added to Expression.

#       (In) Expression: (List) evaluation queue
#       (In) r1: Binding label

Combine-Closure/signature/eval-list/finish
        PEND    tmp,@Combine/Evaluate-List/Finish
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        JUMP    @Combine-Closure/signature/next

#       The eval and eval-list strategies cover the closures that
#       will be encountered most of the time so it'll be helpful
#       to pause here to describe how the Expression register is
#       moved to the stack and how each argument is eventually
#       processed into a result and bound.

#       The first check is to see if anything is left in Arguments
#       not described by the signature, otherwise the arguments
#       were valid so r0 and r1 are restored and the stack is
#       prepared.

#       First, or last after the arguments are ready, Combine/Finish
#       is pushed onto the stack where it can return to the level
#       of recursion begun in Combine/Start with the result of the
#       combination now in the Accumulator.

#       In order to place that result there Combine-Closure/Ready
#       is positioned on the stack so it is reached after processing
#       the arguments is complete and they're ready in Arguments.

#       Before Combine-Closure/Ready come the directives now in
#       Expression. As the source arguments list was scanned in
#       order, the list in Expression is in reverse (ie. the
#       directives for the first argument are at the back of the
#       list). Moving that onto the stack reverses the list again
#       and so this routine ends with the directive to process the
#       first argument on top of the stack with the rest in their
#       natural order.

#       (In) Arguments: unhandled arguments, should be nil.
#       (In) Expression: stack additions in reverse
#       (In) Control-Link: r1 r0 Closure <Frame>

#       This is where the routine started by Combine-Closure (from
#       Combine/Dispatch) finishes and the evaluator begins to
#       execute the plan just built.

#       (Out) Arguments: ()
#       (Out) Expression: ()
#       (Out) Control-Link: (Queue) /Ready Closure /Finish <Frame>

Combine-Closure/signature/finish
        CMPIS?  tmp,args,()     Signature ended with unhandled arguments?
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      LOAD    r1,=clink       Restore spilled registers.
        LOAD    r0,=clink
        LOAD    acc,=clink      Restore the closure.
        PEND    clink,@Combine/Finish
        LOAD    clink,acc
        PEND    clink,@Combine-Closure/Ready
1h      CMPIS?  tmp,expr,()     Finished?
        BRANCH  tmp,@1f
        LOAD    clink,=expr     Move the next item from Expression.
        JUMP    @1b
1h      JUMP    =clink          Arguments is now ().

#       In order to evaluate an argument it gets popped off the
#       stack into Expression and control continues with !Evaluate.
#       After evaluation control will reach Combine/Append-Argument
#       below.

#       (In) Arguments: In-progress list of pre-bound arguments
#       (In) Control-Link: Argument /Append-Argument Binding ...

Combine/Evaluate-Argument
        LOAD    expr,=clink
        JUMP    @!Evaluate

#       When an argument has been evaluated its result is in the
#       Accumulator and it's pushed onto Arguments along with the
#       location it's going to be bound to. If an argument isn't
#       being evaluated then it's popped off the stack as in
#       Combine/Evaluate-Argument but straight onto the Accumulator
#       without going through !Evaluate.

#       (In; Append) Accumulator: Evaluated result
#       (In; Append) Control-Link: Binding ...
#       (In; Copy) Control-Link: Argument Binding ...
#
#       (In/Out) Arguments: In-progress list of pre-bound arguments

Combine/Copy-Argument
        LOAD    acc,=clink
Combine/Append-Argument
        CONS    acc,=clink,acc  Pair the result with its binding location.
        CONS    args,acc,args   Save the pair in Arguments.
        JUMP    =clink          Keep calm.

#       To bind a (remaining) list of arguments of unknown length to a single variable first
# the list terminator is pushed onto Arguments, without a binding label. This will be added later.

#       After preparing to build a new list control will proceed
#       with either Combine/Evaluate-List/Append-Argument or
#       Combine/Evaluate-List/Finish if there were no arguments in
#       the source expression.

#       (In) Arguments: In-progress list of pre-bound arguments

Combine/Evaluate-List/Start
        CONS    args,(),args
        JUMP    =clink

#       (In) Accumulator: Next result
#       (In/Out) Arguments: In-progress list of pre-bound arguments
#                           with in-progress list of remaining arguments
#                           at the front

Combine/Evaluate-List/Append-Argument
        CONS    acc,acc,=args
        CONS    args,acc,args
        JUMP    =clink

#       (In) Arguments: In-progress list of pre-bound arguments
#                       with in-progress list of remaining arguments
#                       at the front
#       (In) Control-Link: Binding Next ...

#       (Out) Arguments: In-progress list of pre-bound arguments
#                        with finished list of remaining arguments
#                        at the front (in reverse)
#       (Out) Control-Link: ...

Combine/Evaluate-List/Finish
        LOAD    expr,=args
        LOAD    acc,()
1h      CMPIS?  tmp,expr,()
        BRANCH  tmp,@1f
        CONS    acc,=expr,acc
        JUMP    @1b
1h      CONS    acc,=clink,acc
        CONS    args,acc,args
        JUMP    =clink

#       Load closure's environment & expand
#       set bindings from args
#       Load body into expression

#       (In) Arguments: Finished list of pre-bound arguments
#       (In) Environment: Caller's run-time environment
#       (In) Control-Link: Closure <Frame>

Combine-Closure/Ready
        LOAD    expr,=clink     Restore closure
        ADDRESS acc,expr
        JUMP    acc

#       This is the default address assigned to a closure before
#       it's compiled.

#       (In) Arguments: Finished list of pre-bound arguments
#       (In) Environment: Caller's run-time environment
#       (In) Expression: Closure
#       (In) Control-Link: <Frame>

#       (Out) Environment: Extended closure environment with arguments bound
#       (Out) Expression: Closure body

!Interpret-Closure
        OPEN    env,expr        Closure environment
        EXTEND  env,env
1h      CMPIS?  tmp,args,()
        BRANCH  tmp,@1f
        DEFINE! env,=args
        JUMP    @1b
1h      LOAD    clink,r0        Prepare to enter !Primitive/do
        BODY    r0,expr         Closure body
        JUMP    @!Primitive/do

#       Returning to the remaining closure signature strategies,
#       the copy strategy copies the argument from the source
#       expression as-is without evaluation.

#       Note that the branch through Combine-Closure/Append-Argument
#       is made directly without wasting space for it on the stack
#       as /Copy-Argument does not need to wait for the evaluator to
#       process the argument first.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Unscanned arguments
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

Combine-Closure/signature/copy?
        LOAD    tmp,'copy
        CMPIS?  tmp,acc,tmp
        BRANCH  =tmp,@Combine-Closure/signature/copy-list?
        PAIR?   tmp,args
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      PEND    tmp,@Combine/Copy-Argument
        CONS    expr,tmp,expr
        CONS    expr,=args,expr
        CONS    expr,r1,expr
        JUMP    @Combine-Closure/signature/next

#       The copy-list strategy directs the evaluator to bind the
#       remaining source arguments without any further processing
#       at all. This works by duplicating the plain copy process
#       but moving the unscanned arguments into the accumulator and
#       continuing as though it was a regular argument to copy.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Remaining arguments (maybe none)
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

Combine-Closure/signature/copy-list?
        LOAD    tmp,'copy-list
        CMPIS?  tmp,acc,tmp
        BRANCH  =tmp,@Combine-Closure/signature/environment?
        PEND    tmp,@Combine/Copy-Argument
        CONS    expr,tmp,expr
        CONS    expr,args,expr
        CONS    expr,r1,expr
        LOAD    args,()
        JUMP    @Combine-Closure/signature/next

#       A closure's strategies describe the arguments which it
#       requires. It may also dictate that additional evaluator
#       state be bound in the closure's extended environment. These
#       strategies must come after all of the copy/eval strategies
#       (of which one of the list strategies, if present, must
#       be last and along); no attempt is made to enforce this here
#       but in the !Primitive/vov routine which creates these
#       extended closures.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Should be ()
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

Combine-Closure/signature/environment?
        LOAD    tmp,'environment
        CMPIS?  tmp,acc,tmp
        BRANCH  =tmp,@Combine-Closure/signature/continuation?
        CMPIS?  tmp,args,()
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      PEND    tmp,@Combine/Copy-Environment
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        JUMP    @Combine-Closure/signature/next

#       Capturing the run-time environment is a simple matter of
#       copying it into the Accumulator.

#       (In) Control-Link: Binding ...
#
#       (In/Out) Arguments: In-progress list of pre-bound arguments
#       (Out) Control-Link: ...

Combine/Copy-Environment
        LOAD    acc,env
        JUMP    @Combine/Append-Argument

#       The only strategy remaining strategy which Lossless supports
#       is to capture the run-time continuation of the closure's
#       caller although there is scope to implement other strategies
#       by handling the unimplemented feature trap.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Should be ()
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

#       The only argument strategy remaining is a continuation.
Combine-Closure/signature/continuation?
        LOAD    tmp,'environment
        CMPIS?  tmp,acc,tmp
        BRANCH  =tmp,@1f
        TRAP    'unimplemented
1h      CMPIS?  tmp,args,()
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand   Too many arguments.
1h      PEND    tmp,@Combine/Copy-Continuation
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        JUMP    @Combine-Closure/signature/next

#       Capturing the run-time continuation is also not supported.

Combine/Copy-Continuation
        TRAP    'unimplemented

#       A primitive works similarly to a closure in most respects
#       except two:

#           Only the eval, copy and copy-list strategies are available.
#
#           The binding location is a number identifying a register.

#       (In) Expression: Primitive object
#       (In) Control-Link: Uncombined-Arguments <Frame>

Combine-Primitive
        LOAD    args,=clink     Restore unprocessed arguments.
        LOAD    clink,expr      Save closure object.
        LOAD    clink,r0        Used for the signature.
        LOAD    clink,r1        Used for each strategy.
        SIGNATURE r0,expr
        LOAD    expr,()         Prepare a queue of evaluation/copy work.

#       Identical to Combine-Closure/signature/next except for
#       continuing at Combine-Primitive/signature/copy? or
#       Combine-Primitive/signature/next.

#       (Out) Accumulator: Strategy label
#       (Out) r1: Binding label
#
#       (In/Out) Arguments: Unscanned arguments
#       (In/Out) Expression: Evaluation queue

Combine-Primitive/signature/next
        CMPIS?  tmp,r0,()       Finished?
        BRANCH  tmp,@Combine-Primitive/signature/finish
        LOAD    acc,=r0         Next formal
        CAR     r1,acc          Register `binding', an integer.
        CDR     acc,acc
        CAR     acc,acc         Strategy
        LOAD    tmp,'eval
        CMPIS?  tmp,acc,tmp
        BRANCH  =tmp,@Combine-Primitive/signature/copy?
        PAIR?   tmp,args
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      PEND    tmp,@Combine/Evaluate-Argument
        CONS    expr,tmp,expr
        CONS    expr,=args,expr
        PEND    tmp,@Combine/Append-Argument
        CONS    expr,tmp,expr
        CONS    expr,r1,expr
        JUMP    @Combine-Primitive/signature/next

#       Also practically identical to Combine-Closure/signature/copy?.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Unscanned arguments
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label

Combine-Primitive/signature/copy?
        LOAD    tmp,'copy
        CMPIS?  tmp,acc,tmp
        BRANCH  =tmp,@Combine-Primitive/signature/copy-list?
        PAIR?   tmp,args
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand   Improper list
1h      PEND    tmp,@Combine/Copy-Argument
        CONS    expr,tmp,expr
        CONS    expr,=args,expr
        CONS    expr,r1,expr
        JUMP    @Combine-Primitive/signature/next

#       The only argument strategy remaining is copy-list which
#       will also always be the last strategy.

#       (In) Accumulator: Strategy label
#       (In) Arguments: Remaining arguments
#       (In) Expression: Evaluation queue
#       (In) r1: Binding label
#
#       (Out) Arguments: ()

Combine-Primitive/signature/copy-list?
        PEND    tmp,@Combine/Copy-Argument
        CONS    expr,tmp,expr
        CONS    expr,args,expr
        CONS    expr,r1,expr
        LOAD    args,()

#       (In) Arguments: Should be ()
#       (In) Expression: Evaluation queue
#       (In) Control-Link: r1 r0 Closure <Frame>
#
#       (Out) Arguments: ()
#       (Out) Expression: ()
#       (Out) Control-Link: (Queue) /Ready Closure /Finish <Frame>

Combine-Primitive/signature/finish
        CMPIS?  tmp,args,()
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      LOAD    args,expr
        LOAD    r1,=clink
        LOAD    r0,=clink
        LOAD    expr,=clink
        PEND    clink,@Combine/Finish
        LOAD    clink,expr
        PEND    clink,@Combine-Primitive/Ready
1h      CMPIS?  tmp,args,()
        BRANCH  tmp,@1f
        LOAD    clink,=args
        JUMP    @1b
1h      JUMP    =clink          Args is now ()

#       The primitives are defined such that the last argument,
#       first in Arguments which has been built in reverse, has as
#       the number identifying the highest used register as its
#       binding location. Unless there are no arguments and no
#       registers to spill. There is no need to check the remaining
#       arguments' binding register.
#
#       The primitive is responsible for restoring the spilled
#       registers before returning control to the caller.
#
#       This assembly language's addressing syntax could do with
#       an addressing mode to calculate the jump-in point to start
#       from rather than iterating over each choice in turn.

Combine-Primitive/Ready
        ADDRESS acc,=clink      Discard the closure after obtaining its address.
        CMPIS?  tmp,args,()
        BRANCH  tmp,acc         If there are no arguments proceed directly
;                               to the primitive implementation.
        CAR     expr,args       First argument.
        CAR     tmp,expr        First register number.
        CMPIS?  tmp,tmp,0
        BRANCH  tmp,@0f
        CAR     tmp,expr        There's no spare space to store the register
;                               number! Extract it again.
        CMPIS?  tmp,tmp,1
        BRANCH  tmp,@1f
        CAR     tmp,expr
        CMPIS?  tmp,tmp,2
        BRANCH  tmp,@2f
        CAR     tmp,expr
        CMPIS?  tmp,tmp,3
        BRANCH  tmp,@3f
        TRAP    'lossless-error No primitive has more than 4 arguments; this
;                               instruction `is' unreachable.
3h      LOAD    clink,r3        Spill and fill the registers starting
;                               with the last argument.
        CDR     r3,expr         The argument, discarding the bindling location.
        CDR     args,args       The remaining arguments list.
        CAR     expr,args       Next argument pair.
2h      LOAD    clink,r2        Repeat, or start here.
        CDR     r2,expr
        CDR     args,args
        CAR     expr,args
1h      LOAD    clink,r1        Repeat, or start here.
        CDR     r1,expr
        CDR     args,args
        CAR     expr,args
0h      LOAD    clink,r0        Repeat, or start here.
        CDR     r0,expr
        CDR     args,args
        JUMP    acc             Jump into the primitive.

######## End of the evaluator.

#       Symbols in the root environment are bound to primitives,
#       becoming `operators'. As described above the evaluator is
#       directed to an address to perform the primitive operation
#       after loading its arguments into registers. Restoring the
#       prior values of the registers and returning to the caller
#       is a very common operation and so a common set of routines
#       to return from another function is defined here for general
#       use.

!Primitive.Default
        TRAP    'unimplemented

!Restore/r7     LOAD    r7,=clink
!Restore/r6     LOAD    r6,=clink
!Restore/r5     LOAD    r5,=clink
!Restore/r4     LOAD    r4,=clink
!Restore/r3     LOAD    r3,=clink
!Restore/r2     LOAD    r2,=clink
!Restore/r1     LOAD    r1,=clink
!Restore/r0     LOAD    r0,=clink
                JUMP    =clink

#       Some routines spill higher registers and leave lower-valued
#       registers alone, such as when a routine shares registers
#       with a routine which it calls.

!Restore/r7-1   LOAD    r7,=clink
!Restore/r6-1   LOAD    r6,=clink
!Restore/r5-1   LOAD    r5,=clink
!Restore/r4-1   LOAD    r4,=clink
!Restore/r3-1   LOAD    r3,=clink
!Restore/r2-1   LOAD    r2,=clink
!Restore/r1-1   LOAD    r1,=clink
                JUMP    =clink
!Restore/r7-2   LOAD    r7,=clink
!Restore/r6-2   LOAD    r6,=clink
!Restore/r5-2   LOAD    r5,=clink
!Restore/r4-2   LOAD    r4,=clink
!Restore/r3-2   LOAD    r3,=clink
!Restore/r2-2   LOAD    r2,=clink
                JUMP    =clink
!Restore/r7-3   LOAD    r7,=clink
!Restore/r6-3   LOAD    r6,=clink
!Restore/r5-3   LOAD    r5,=clink
!Restore/r4-3   LOAD    r4,=clink
!Restore/r3-3   LOAD    r3,=clink
                JUMP    =clink
!Restore/r7-4   LOAD    r7,=clink
!Restore/r6-4   LOAD    r6,=clink
!Restore/r5-4   LOAD    r5,=clink
!Restore/r4-4   LOAD    r4,=clink
                JUMP    =clink
!Restore/r7-5   LOAD    r7,=clink
!Restore/r6-5   LOAD    r6,=clink
!Restore/r5-5   LOAD    r5,=clink
                JUMP    =clink
!Restore/r7-6   LOAD    r7,=clink
!Restore/r6-6   LOAD    r6,=clink
                JUMP    =clink

#       The first pair of primitives which will be defined are
#       lambda and vov for building closures. You'd expect `if' or
#       something even more fundamental to come first but for a
#       machine which is built on exactly the concepts of numbers
#       and conditional branching, it's surprising how far you can
#       get without either.
#
#       The lambda primitive receives two arguments which are both
#       unevaluated and therefore need to be validated.
#
#       A valid lambda formals list is a list of unique symbols;
#       the list may be proper or improper provided the dotted tail
#       is also a symbol.
#
#       A closure is the same whether from lambda or vov. While
#       validating the lambda formals a signature is created to
#       match the formals expected by vov. They then share the same
#       code to validate the body and finish.
#
#       Registers r1 to r4 are spilled to the stack while processing
#       the formals list. The final validated signature is built
#       in r4 while r1 to r3 are spare space for the validation.
#
#       (In) Control-Link: ...
#       (In) r0: formals (unvalidated)
#       (In) r1: body (unvalidated)
#
#       (Out) Control-Link: r4 r3 r2 r1 ...
#       (Out) r2: (eval)
#       (Out) r3: Hashtable of binding labels
#       (Out) r4: Budding signature

!Primitive/lambda

        LOAD    clink,r1        Spill the body; holds the next label.
        LOAD    clink,r2        Common tail of all evaluating arguments.
        LOAD    clink,r3        Hashtable of discovered binding labels.
        LOAD    clink,r4        Compiled formals.
        LOAD    r4,()
        LOAD    r2,'eval
        CONS    r2,r2,()        (eval)
        TABLE   r3,0

#       Each time around the loop the remainder of the list is
#       checked to see if it's really a symbol indicating that
#       closure is variadic and should consume and evaluate all
#       remaining arguments.
#
#       Otherwise if the next label is unique a new strategy is
#       created for the binding and included in the signature in r4.
#
#       (In) r0: (Remaining) formals
#       (In) r2: (eval)
#       (In) r3: Hashtable of binding labels
#       (In) r4: Budding signature

Primitive/lambda/validate-formals/next
        CMPIS?  tmp,r0,()       Finished?
        BRANCH  tmp,@Primitive/lambda/validate-formals/finish
        SYMBOL? tmp,r0          Is the (remaining) list really a symbol?
        BRANCH  tmp,@Primitive/lambda/validate-formals/consume
        PAIR?   tmp,r0          Is the remaining list list-like?
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r1,r0           Next binding label.
        SYMBOL? tmp,r1
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      EXISTS? tmp,r3,r1       Check that this label is unique.
        BRANCH  =tmp,@1f
        TRAP    'conflicted-binding
1h      CONS    tmp,r1,r1
        DEFINE! r3,tmp          Record that this label was used.
        CONS    tmp,r1,r2       Create a new signature strategy for this
;                               binding.
        CONS    r4,tmp,r4       Include the strategy in the signature.
        CDR     r0,r0           Next formal.
        JUMP    @Primitive/lambda/validate-formals/next

#       If the lambda formals was a single symbol, or an improper
#       list with a symbol in the dotted tail position, the signature
#       is completed with a strategy to evaluate and consume all
#       remaining arguments. The binding is checked for uniqness
#       but there's no need to record it in r3 which is about to
#       be discarded.
#
#       (In) r0: Binding label
#       (In) r3: Hashtable of binding labels
#       (In) r4: Budding signature

Primitive/lambda/validate-formals/consume
        EXISTS? tmp,r3,r0
        BRANCH  =tmp,@1f
        TRAP    'conflicted-binding
1h      LOAD    r2,'eval-list
        CONS    r2,r2,()
        CONS    tmp,r0,r2
        CONS    r4,tmp,r4
        JUMP    @Primitive/lambda/validate-formals/finish

#       After validating the lambda formals a signature representing
#       them has been constructed in r4 in reverse which is copied
#       in the correct order into r0. The spilled registers are
#       restored and control proceeds with Primitive/vov/validate-body
#       to construct the closure.
#
#       (In) Control-Link: r4 r3 r2 r1 ...
#       (In) r4: Reverse signature

#       (Out) Control-Link: ...
#       (Out) r0: Valid signature
#       (Out) r1: Body (unvalidated)

Primitive/lambda/validate-formals/finish
        LOAD    r0,()
1h      CMPIS?  tmp,r4,()
        BRANCH  tmp,@1f
        CAR     tmp,r4
        CONS    r0,tmp,r0
        CDR     r4,r4
        JUMP    @1b
1h      LOAD    r4,=clink
        LOAD    r3,=clink
        LOAD    r2,=clink
        LOAD    r1,=clink
        JUMP    @Primitive/vov/validate-body

#       A vov expression creates a closure with a richer possible
#       signature than the strategies available to a lambda expression.
#       In addition to merely evaluating each argument an `operative'
#       closure can receive the arguments without evaluating them
#       or various kinds of run-time state.
#
#       The formals passed to vov precisely match the signature of
#       the closure that will be created and so validation is just
#       validation without having to process the list like lambda
#       does. The lambda primitive replaces its formals in r0 with
#       a signature compatible with this routine which is why they
#       are able to share the final steps in Primitive/vov/validate-body.
#
#       The formals list as passed and the body are both spilled
#       along with the other three registers this routine needs;
#       they will be used as-is after the work to validate them is
#       discarded.
#
#       r3 and r4 hold a hashtable which records the formals (r3) or
#       state (r4) which have been identified. r2 is used for
#       additional working space.
#
#       (In) Control-Link: ...
#       (In) r0: Unvalidated formals
#       (In) r1: Unvalidated closure body
#
#       (Out) Control-Link: r4 r3 r2 r1 r0 ...
#       (Out) r3: hashtable of identified binding labels.
#       (Out) r4: hashtable of identified state requests.

!Primitive/vov
        LOAD    clink,r0        Walking along the formals list
        LOAD    clink,r1        Next formal list
        LOAD    clink,r2        Working space
        LOAD    clink,r3
        LOAD    clink,r4
        TABLE   r3,0            Collected formal labels
        TABLE   r4,0            Collected state requests
        JUMP    @Primitive/vov/validate-formals/first

#       With a valid formals signature in r0 validating the body
#       is simply a matter of ensuring it's a proper list.
#
#       (In) Control-Link: ...
#       (In) r0: Formals (validated)
#       (In) r1: Body (unvalidated)

Primitive/vov/validate-body
        CMPIS?  tmp,r1,()
        BRANCH  tmp,@3f
        LOAD    acc,r1
1h      PAIR?   tmp,acc         Looks like a list so far?
        BRANCH  tmp,@2f
        TRAP    'incompatible-operand
2h      CDR     acc,acc         Remaining instructions.
        CMPIS?  tmp,acc,()      Finished?
        BRANCH  =tmp,@1b
3h      CLOSURE acc,r0,r1       Close over processed/validated formals &
;                               validated body.
        JUMP    @!Restore/r1

#       After validating the formals the original list is restored
#       along with the body now ready for its own validation.
#
#       (In) Control-Link: r4 r3 r2 r1 r0 ...
#
#       (Out) Control-Link: ...
#       (Out) r0: Formals (original list, now validated)
#       (Out) r1: Body (unvalidated)

Primitive/vov/validate-formals/finish
        LOAD    r4,=clink
        LOAD    r3,=clink
        LOAD    r2,=clink
        LOAD    r1,=clink
        LOAD    r0,=clink       Restore formals as passed
        JUMP    @Primitive/vov/validate-body

#       If scanning reaches the end of the formals list then it was
#       valid otherwise control continues with the next.
#
#       (In) r0: (Remaining) unvalidated formals

Primitive/vov/validate-formals/next
        CDR     r0,r0
Primitive/vov/validate-formals/first
        CMPIS?  tmp,r0,()
        BRANCH  tmp,@Primitive/vov/validate-formals/finish

#       Following on from Primitive/vov/validate-formals/next, here
#       each individual formal is validated. The formals passed to
#       the vov primitive are the same as the signature the final
#       closure will have, namely a list of lists, each inner list
#       of two items: the formal label and argument strategy.
#
#       Any strategy other than plain eval or copy indicates the
#       end of any more copying or evaluating strategies and so
#       control continues with an alternate but similar algorithm
#       starting with Primitive/vov/validate-formals/next%final.
#
#       (In) r0: Remaining unvalidated formals
#       (In) r3: Hashtable containing all binding labels seen
#       (In) r4: Hashtable containing all state requests seen

Primitive/vov/validate-formals/continue
        PAIR?   tmp,r0          Does the (next) formal item continue a list?
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r1,r0           Next formal; should also be list.
        PAIR?   tmp,r1
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r2,r1           Binding label, should be unique symbol.
        SYMBOL? tmp,r2
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      EXISTS? tmp,r3,r2       See if the binding label has been used already.
        BRANCH  =tmp,@1f
        TRAP    'conflicted-binding
1h      CONS    tmp,r2,r2       Create a record of this label.
        DEFINE! r3,tmp
        CDR     r2,r1           The argument strategy, should be a list of one.
        PAIR?   tmp,r2
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      CDR     tmp,r2
        CMPIS?  tmp,tmp,()
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r2,r2           The argument strategy.
        LOAD    tmp,'eval
        CMPIS?  tmp,r2,tmp
        BRANCH  tmp,@Primitive/vov/validate-formals/next
        LOAD    tmp,'copy
        CMPIS?  tmp,r2,tmp
        BRANCH  tmp,@Primitive/vov/validate-formals/next
        LOAD    tmp,'eval-list
        CMPIS?  tmp,r2,tmp
        BRANCH  tmp,@Primitive/vov/validate-formals/next%final
        LOAD    tmp,'copy-list
        CMPIS?  tmp,r2,tmp
        BRANCH  tmp,@Primitive/vov/validate-formals/next%final
        LOAD    tmp,'environment
        CMPIS?  tmp,r2,tmp
        BRANCH  =tmp,@2f
        EXISTS? tmp,r4,r2       Has the environment been requested already?
        BRANCH  =tmp,@1f
        TRAP    'incompatible-operand
1h      CONS    tmp,r2,r2
        DEFINE! r4,tmp          ... it has now.
        JUMP    @Primitive/vov/validate-formals/next%final
2h      LOAD    tmp,'continuation
        CMPIS?  tmp,r2,tmp
        BRANCH  tmp,@2f
        EXISTS? tmp,r4,r2       Requested continuation already?
        BRANCH  =tmp,@1f
2h      TRAP    'incompatible-operand
1h      CONS    tmp,r2,r2
        DEFINE! r4,tmp          Record this request.
        JUMP    @Primitive/vov/validate-formals/next%final

#       This is a copy of Primitive/vov/validate-formals/next &
#       Primitive/vov/validate-formals/continue for use when the
#       copying and evaluation strategies are no longer permitted
#       in a valid formals signature.
#
#       (In) r0: Remaining unvalidated formals
#       (In) r3: Hashtable containing all binding labels seen
#       (In) r4: Hashtable containing all state requests seen
#
#       Possible improvement: store #t in r4 until positional formals
#       have finished, then replace it with a hashtable and test
#       for that before validating each formal. Copy pasta for now.
#
Primitive/vov/validate-formals/next%final
        CDR     r0,r0
        CMPIS?  tmp,r0,()
        BRANCH  tmp,@Primitive/vov/validate-formals/finish
Primitive/vov/validate-formals/continue%final
1h      PAIR?   tmp,r0
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r1,r0           Formal.
        PAIR?   tmp,r1
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r2,r1           Label.
        SYMBOL? tmp,r2
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      EXISTS? tmp,r3,r2
        BRANCH  =tmp,@1f
        TRAP    'conflicted-binding
1h      CONS    tmp,r2,r2
        DEFINE! r3,tmp          Record this label.
        CDR     r2,r1           (Strategy).
        PAIR?   tmp,r2
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      CDR     tmp,r2
        CMPIS?  tmp,tmp,()
        BRANCH  tmp,@1f
        TRAP    'incompatible-operand
1h      CAR     r2,r2           Strategy.
        LOAD    tmp,'environment
        CMPIS?  tmp,r2,tmp
        BRANCH  =tmp,@2f
        EXISTS? tmp,r4,r2
        BRANCH  =tmp,@1f
        TRAP    'incompatible-operand
1h      CONS    tmp,r2,r2
        DEFINE! r4,tmp          Record this request.
        JUMP    @Primitive/vov/validate-formals/next%final
2h      LOAD    tmp,'continuation
        CMPIS?  tmp,r2,tmp
        BRANCH  =tmp,@2f
        EXISTS? tmp,r4,r2
        BRANCH  =tmp,@1f
2h      TRAP    'incompatible-operand
1h      CONS    tmp,r2,r2
        DEFINE! r4,tmp          Record this request.
        JUMP    @Primitive/vov/validate-formals/next%final








########

!Primitive/null?
        CMPIS?  acc,r0,()
        JUMP    =clink
!Primitive/pair?
        PAIR?   acc,r0
        JUMP    =clink
!Primitive/symbol?
        SYMBOL? acc,r0
        JUMP    =clink
!Primitive/segment?
        SEGMENT? acc,r0
        JUMP    =clink
!Primitive/array?
        ARRAY?  acc,0
        JUMP    =clink

!Primitive/false?
        CMPIS?  acc,r0,#f
        JUMP    =clink
!Primitive/true?
        CMPIS?  acc,r0,#t
        JUMP    =clink
!Primitive/boolean?
        CMPIS?  acc,r0,#f
        BRANCH  acc,@1f
        CMPIS?  acc,r0,#t
1h      JUMP    =clink

!Primitive/is?
        CMPIS?  acc,r0,r1
        JUMP    =clink

1h      TRAP    'incompatible-operand
!Primitive/cons
        CONS    acc,r0,r1
        JUMP    @!Restore/r1
!Primitive/car
        PAIR?   acc,r0
        BRANCH  =acc,@1b
        CAR     acc,r0
        JUMP    @!Restore/r0
!Primitive/cdr
        PAIR?   acc,r0
        BRANCH  =acc,@1b
        CDR     acc,r0
        JUMP    @!Restore/r0

1h      TRAP    'incompatible-operand
!Primitive/symbol/key
        SYMBOL? acc,r0
        BRANCH  =acc,@1b
#       SLO     acc,'symbol/key
        JUMP    =clink
!Primitive/symbol/segment
        SYMBOL? acc,r0
        BRANCH  =acc,@1b
#       SLO     acc,'symbol/segment     Read-only
        JUMP    =clink

#       r0: length
#       r1: alignment
1h      TRAP    'incompatible-operand
!Primitive/new-segment
        CMPLE?  tmp,r0,0
        BRANCH  tmp,@1b
        CMPLE?  tmp,r1,0
        BRANCH  tmp,@1b
#       SLO     acc,'new-segment
        JUMP    =clink

1h      TRAP    'incompatible-operand
!Primitive/segment/resize!
        SEGMENT? tmp,r0
        BRANCH  =tmp,@1b
        CMPLE?  tmp,r1,0
        BRANCH  tmp,@1b
#       SLO     acc,'segment/resize!
        JUMP    =clink

1h      TRAP    'incompatible-operand
!Primitive/segment/length
        SEGMENT? tmp,r0
        BRANCH  =tmp,@1b
#       SLO     acc,'segment/length
        JUMP    =clink

1h      LOAD    r4,=clink
2h      LOAD    r3,=clink
        TRAP    'incompatible-operand
!Primitive/segment->symbol
        PEND    clink,@3f
        JUMP    @!Primitive/segment/length
3h      LOAD    clink,r3        Prepare to clobber r3
        LOAD    r3,acc          Segment length
        CMPGE?  tmp,r1,0
        BRANCH  =tmp,@2b        !(off >= 0)?
        CMPGE?  tmp,r1,r3
        BRANCH  tmp,@2b         off >= max?
        CMPGE?  tmp,r2,0
        BRANCH  =tmp,@2b        !(length >= 0)?
        LOAD    clink,r4        Prepare to clobber r4
        ADD     r4,r1,r2
        CMPLE?  tmp,r4,r3
        BRANCH  tmp,@1b         (off + length >= max)?
        LOAD    r4,=clink       Restore clobbered registers.
        LOAD    r3,=clink
#       SLO     acc,'segment->symbol
        JUMP    =clink

#       r0: length
#       r1: offset
#       r2: filler
1h      TRAP    'incompatible-operand
!Primitive/new-array
        CMPGE?  tmp,r0,0
        BRANCH  =tmp,@1b
        INTEGER? tmp,r1
        BRANCH  =tmp,@1b
#       SLO     acc,'new-array
        JUMP    =clink

#       r0: array
#       r1: new length
#       r2: new offset
#       r3: new filler
1h      TRAP    'incompatible-operand
!Primitive/array/resize!
        ARRAY?  tmp,r0
        BRANCH  =tmp,@1b
        CMPGE?  tmp,r1,0
        BRANCH  =tmp,@1b
        INTEGER? tmp,r2
        BRANCH  =tmp,@1b
#       SLO     acc,'array/resize!
        JUMP    =clink

1h      TRAP    'incompatible-operand
!Primitive/array/length
        ARRAY?  tmp,r0
        BRANCH  =tmp,@1b
#       SLO     acc,'array/length
        JUMP    =clink

1h      TRAP    'incompatible-operand
!Primitive/array/offset
        ARRAY?  tmp,r0
        BRANCH  =tmp,@1b
#       SLO     acc,'array/offset
        JUMP    =clink

#       r0: array
#       r1: index + offset
#       r2 (set!): value
1h      LOAD    r2,=clink
        TRAP    'incompatible-operand
!Primitive/array/ref
#       SLO     acc,'array/offset
        PEND    clink,@Primitive/array/ref/imp
Primitive/array/ref/find
        LOAD    clink,r2
        SUB     r2,r1,acc
        CMPLT?  tmp,r2,0
        BRANCH  tmp,@1b
#       SLO     acc,'array/length
        CMPGE?  tmp,r2,acc
        BRANCH  tmp,@1b
        LOAD    r1,r2
        LOAD    r2,=clink
        JUMP    =clink
!Primitive/array/set!
#       SLO     acc,'array/offset
        PEND    clink,@Primitive/array/set!/imp
        JUMP    @Primitive/array/ref/find
Primitive/array/ref/imp
#       SLO     acc,'array/ref
        JUMP    =clink
Primitive/array/set!/imp
#       SLO     acc,'array/set!
        JUMP    =clink

# TODO: Hashtables

########

!Primitive/+
        ADD     acc,r0,r1
        JUMP    @!Restore/r1
!Primitive/-
        SUB     acc,r0,r1
        JUMP    @!Restore/r1
!Primitive/*
        MUL     acc,r0,r1
        JUMP    @!Restore/r1

!Primitive/current-environment
        LOAD    acc,env
        JUMP    =clink

!Primitive/root-environment
        LOAD    acc,root
        JUMP    =clink

!Primitive/do
        PEND    acc,@Primitive/do/next
        CMPIS?  tmp,r0,()
        BRANCH  =tmp,@1f
        LOAD    acc,#VOID
        JUMP    @!Restore/r0
        LOAD    args,()
1h      PAIR?   tmp,r0
        BRANCH  tmp,@2f
        CMPIS?  tmp,r0,()
        BRANCH  tmp,@3f
        TRAP    'incompatible-operand
2h      CONS    args,acc,args
        CONS    args,=r0,args
        JUMP    @1b

3h      LOAD    r0,=clink
1h      LOAD    clink,=args
        LOAD    clink,=args
        CMPIS?  tmp,args,()
        BRANCH  =tmp,@1b

        LOAD    tmp,=clink      Discard first branch directive.
Primitive/do/next
        LOAD    expr,=clink
        JUMP    @!Evaluate






Primitive/read-expression/terminator?
        CMPEQ?  acc,r3,#x28     (
        BRANCH  acc,@1f
        CMPEQ?  acc,r3,#x29     )
        BRANCH  acc,@1f
Primitive/read-expression/space?
        CMPEQ?  acc,r3,#x20     Space
        BRANCH  acc,@1f
        CMPEQ?  acc,r3,#x0a     Line Feed
        BRANCH  acc,@1f
        CMPEQ?  acc,r3,#x09     Horizontal Tab
1h      JUMP    =clink

Primitive/read-expression/digit?
        CMPGE?  acc,r3,#x30     0
        BRANCH  =acc,@1f
        CMPLE?  acc,r3,#x39     9
1h      JUMP    =clink

Primitive/read-expression/printable?
        CMPGT?  acc,r3,#x20     Control codes & space
        BRANCH  =acc,@1f
        LOAD    tmp,#x7f        Delete & Non-ASCII
        CMPLT?  acc,r3,tmp
1h      JUMP    =clink

#       These characters will become unforbidden as their feature
#       is implemented.
Primitive/read-expression/unimplemented-or-forbidden?
        LOAD    tmp,#x7b        {
        CMPEQ?  acc,r3,tmp
        BRANCH  acc,@1f
        LOAD    tmp,#x7d        }
        CMPEQ?  acc,r3,tmp
        BRANCH  acc,@1f
        LOAD    tmp,#x5b        [
        CMPEQ?  acc,r3,tmp
        BRANCH  acc,@1f
        LOAD    tmp,#x5d        ]
        CMPEQ?  acc,r3,tmp
        BRANCH  acc,@1f
        CMPEQ?  acc,r3,#x24     $
        BRANCH  acc,@1f
        CMPEQ?  acc,r3,#x27     '
        BRANCH  acc,@1f
        CMPEQ?  acc,r3,#x2c     ,
        BRANCH  acc,@1f
        LOAD    tmp,#x60        `
        CMPEQ?  acc,r3,tmp
        BRANCH  acc,@1f
        CMPEQ?  acc,r3,#x3b     ;
        BRANCH  acc,@1f
Primitive/read-expression/forbidden?
        LOAD    tmp,#x5c        \
        CMPEQ?  acc,r3,tmp
1h      JUMP    =clink


#       (In) r0: segment
#       (In) r1: position
#       (In) r2: length
#
#       (Out) Accumulator: Attempt to read past the end?
#       (Out) r3: (if not) the byte.
#
Primitive/read-expression/source-byte
        CMPGE?  acc,r1,r2
        BRANCH  acc,@1f
        PEEK    r3,r0,r1
1h      JUMP    =clink

#       (In) r0: segment
#       (In) r1: start/offset
#
#       (Out) Accumulator: Object
#       (Out) r0: segment
#       (Out) r1: consumed
#
#       -: r2: segment length
#       -: r3: byte, result type
#       -: r4: base offset, object
#       -: r5: negative?
#       -: r6: numeric sum
#       -: r7: numeric multiplier
#
!Primitive/read-expression
        SEGMENT? tmp,r0
        BRANCH  tmp,@1f
0h      TRAP    'incompatible-operand
1h      INTEGER? tmp,r1
        BRANCH  =tmp,@0b
        CMPLT?  tmp,r1,0
        BRANCH  tmp,@0b
        LENGTH  acc,r0
        CMPGE?  tmp,r1,acc
        BRANCH  tmp,@0b
#       SLO     acc,'segment/length
#       CMPGE?  tmp,r1,acc
#       BRANCH  tmp,@0b
        LOAD    clink,r2
        LOAD    clink,r3
        LOAD    clink,r4
        LOAD    clink,r5
        LOAD    clink,r6
        LOAD    clink,r7
        LOAD    r2,acc
        PEND    clink,@Primitive/read-expression/finished
        JUMP    @Primitive/read-expression/imp

#       (In)    Accumulator: Expression
#       (In)    r1: offset
#       (In)    r3: type of expression
#                   close
#                   dot
#                   eof
#                   finish
#
Primitive/read-expression/finished
        LOAD    tmp,'object
        CMPIS?  tmp,r3,tmp
        BRANCH  =tmp,@1f
        JUMP    @!Restore/r7-2
1h      LOAD    tmp,'close
        CMPIS?  tmp,r3,tmp
        BRANCH  =tmp,@1f
        TRAP    'unopened-list
1h      LOAD    tmp,'dot
        CMPIS?  tmp,r3,tmp
        BRANCH  =tmp,@1f
        TRAP    'non-list-tail
#       Is eof
1h      TRAP    'missing

#       This is the heart of the read function.
#

Primitive/read-expression/back-up
        SUB     r1,r1,1
        JUMP    =clink          Probably to the next instruction.
Primitive/read-expression/next
        ADD     r1,r1,1
Primitive/read-expression/imp
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/source-byte
1h      BRANCH  =acc,@1f
        LOAD    r3,'eof
        JUMP    =clink
1h      PEND    clink,@1f
        JUMP    @Primitive/read-expression/space?
1h      BRANCH  acc,@Primitive/read-expression/next
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/printable?
1h      BRANCH  acc,@1f
        TRAP    'unprintable
1h      PEND    clink,@1f
        JUMP    @Primitive/read-expression/unimplemented-or-forbidden?
1h      BRANCH  =acc,@1f
        TRAP    'syntax-error
#
#       In r3 is a printable, non-space character that's valid to
#       begin an expression.
1h      CMPIS?  tmp,r3,#x28     (
        BRANCH  tmp,@Primitive/read-expression/begin-list
1h      CMPIS?  tmp,r3,#x2e     .
        BRANCH  =tmp,@1f
        ADD     r1,r1,1
        LOAD    r3,'dot
        JUMP    =clink
1h      CMPIS?  tmp,r3,#x29     )
        BRANCH  =tmp,@1f
#       ADD     r1,r1,1
        LOAD    acc,()
        LOAD    r3,'close
        JUMP    =clink
1h      CMPIS?  tmp,r3,#x23     #
        BRANCH  tmp,@Primitive/read-expression/special
1h      CMPIS?  tmp,r3,#x2d     -; offset is not incremented yet
        BRANCH  =tmp,@1f
        LOAD    r5,#t
        JUMP    @Primitive/read-expression/possible-number
1h      CMPIS?  tmp,r3,#x2b     +; offset is not incremented yet
        BRANCH  =tmp,@1f
        LOAD    r5,#f
        JUMP    @Primitive/read-expression/possible-number
1h      PEND    clink,@1f
        JUMP    @Primitive/read-expression/digit?
1h      BRANCH  acc,@Primitive/read-expression/number
        JUMP    @Primitive/read-expression/symbol

#       This is the other heart which recursively reads expressions
#       to form them into lists.
#
Primitive/read-expression/begin-list
        LOAD    clink,()
        PEND    clink,@Primitive/read-expression/continue-list
        JUMP    @Primitive/read-expression/next

#       (In)    Accumulator: Expression
#       (In)    r1: offset
#       (In)    r3: type of expression
#
Primitive/read-expression/continue-list
        LOAD    tmp,'object
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@1f
        LOAD    tmp,'close
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/close-list
        LOAD    tmp,'dot
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/list-tail
        TRAP    'unclosed-list  From eof.

1h      CONS    clink,acc,=clink
        PEND    clink,@Primitive/read-expression/continue-list
        JUMP    @Primitive/read-expression/next

#       The close symbol has placed () in the accumulator, when
#       reached from Primitive/read-expression/list-tail/finish
#       that is replaced with the dotted tail.
#
Primitive/read-expression/close-list
        LOAD    r3,=clink
1h      CMPIS?  tmp,r3,()
        BRANCH  tmp,@2f
        CONS    acc,=r3,acc
        JUMP    @1b
2h      LOAD    r3,'object
        JUMP    =clink

#       Expects two more 'expressions'; a finished expression
#       followed by close.
#
Primitive/read-expression/list-tail
        CMPIS?  tmp,clink,()    Just started?
        BRANCH  =tmp,@1f
        TRAP    'non-list-tail
1h      PEND    clink,@Primitive/read-expression/list-tail/expression
        JUMP    @Primitive/read-expression/next

Primitive/read-expression/list-tail/expression
        LOAD    tmp,'object
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@2f
        LOAD    tmp,'dot
        CMPIS?  tmp,r3,tmp
        BRANCH  =tmp,@1f
        TRAP    'double-tail
1h      LOAD    tmp,'close
        CMPIS?  tmp,r3,tmp
        BRANCH  =tmp,@1f
        TRAP    'unterminated-tail
1h      TRAP    'unclosed-list  Is EOF.
2h      LOAD    clink,acc
        PEND    clink,@Primitive/read-expression/list-tail/finish
        JUMP    @Primitive/read-expression/next

Primitive/read-expression/list-tail/finish
        LOAD    tmp,'close
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@2f
        LOAD    tmp,'dot
        CMPIS?  tmp,r3,tmp
        BRANCH  =tmp,@1f
        TRAP    'double-tail
1h      LOAD    tmp,'eof
        CMPIS?  tmp,r3,tmp
        BRANCH  =tmp,@1f
        TRAP    'unclosed-list
1h      TRAP    'tail-mid-list
2h      LOAD    acc,=clink      Restore the dotted tail.
        JUMP    @Primitive/read-expression/close-list












#       It's all just boring text parsing from here.
#
#       (In)    r0: segment
#       (In)    r1: first byte offset
#
Primitive/read-expression/symbol
        LOAD    r4,r1
Primitive/read-expression/symbol/next
        ADD     r1,r1,1
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/source-byte
1h      BRANCH  acc,@Primitive/read-expression/symbol/finish ... if #eof.
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/terminator?
1h      BRANCH  =acc,@1f
        PEND    clink,@Primitive/read-expression/back-up
        JUMP    @Primitive/read-expression/symbol/finish
1h      PEND    clink,@1f
        JUMP    @Primitive/read-expression/printable?
1h      BRANCH  acc,@2f
        TRAP    'unprintable
2h      PEND    clink,@1f
        JUMP    @Primitive/read-expression/forbidden?
1h      BRANCH  =acc,@Primitive/read-expression/symbol/next
        TRAP    'syntax-error

#       (In)    r0: segment
#       (In)    r1: terminal offset
#       (In)    r4: starting offset

#       (Out)   Accumulator: symbol
#       (Out)   r0: segment
#       (Out)   r1: terminal offset
#       (Out)   r2: segment length
#       (Out)   r3: 'object

Primitive/read-expression/symbol/finish
        SUB     r3,r1,r4        Symbol length
        SYMBOL  r0,r4,r3
        LOAD    r3,'object
        JUMP    =clink

#       (In)    r0: segment
#       (In)    r1: starting (sign) offset
#
#       -       r4: negate?

Primitive/read-expression/special
        ADD     r1,r1,1
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/source-byte
1h      BRANCH  =acc,@2f        if !#eof.
        TRAP    'syntax-error
2h      PEND    clink,@1f
        JUMP    @Primitive/read-expression/printable?
1h      BRANCH  acc,@2f
        TRAP    'unprintable
2h      LOAD    tmp,#x46        F
        CMPIS?  tmp,r3,tmp
        BRANCH  =tmp,@1f
2h      LOAD    r4,#f
        JUMP    @Primitive/read-expression/boolean
1h      LOAD    tmp,#x66        f
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@2b
        LOAD    tmp,#x54        T; use r4 to save a few ops
        CMPIS?  r4,r3,tmp
        BRANCH  r4,@Primitive/read-expression/boolean
        LOAD    tmp,#x74        t
        CMPIS?  r4,r3,tmp
        BRANCH  r4,@Primitive/read-expression/boolean
        LOAD    tmp,#x5c        \
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/rune
        JUMP    @Primitive/read-expression/special-number

Primitive/read-expression/boolean
3h      ADD     r1,r1,1
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/source-byte
1h      BRANCH  acc,@2f         if #eof.
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/terminator?
1h      BRANCH  =acc,@3f
        SUB     r1,r1,1
        JUMP    @2f
3h      TRAP    'syntax-error
2h      LOAD    acc,r4
        LOAD    r3,'object
        JUMP    =clink

#       A sign byte has been encountered (r5 is true if it's `-'),
#       r1 has not advanced.

Primitive/read-expression/possible-number
        LOAD    r4,r1           Save the sign byte offset.
        ADD     r1,r1,1
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/source-byte
1h      BRANCH  acc,@Primitive/read-expression/symbol/finish ... if #eof.
        PEND    clink,@1f       Look for a digit starting a signed
;                               base 10 number.
        JUMP    @Primitive/read-expression/digit?
1h      BRANCH  acc,@Primitive/read-expression/number
        CMPIS?  acc,r3,#x23     #
        BRANCH  =acc,@1f
        ADD     r1,r1,1         Found a signed number; move to the base
;                               indicator character.
        PEND    clink,@Primitive/read-expression/special-number/imp
        JUMP    @Primitive/read-expression/source-byte
1h      LOAD    r1,r4           Move back to [-+].
        JUMP    @Primitive/read-expression/symbol/next

Primitive/read-expression/special-number
        LOAD    r5,#f
        JUMP    @1f
Primitive/read-expression/special-number/imp
        BRANCH  =acc,@1f        COMEFROM @Primitive/read-expression/source-byte
        TRAP    'syntax-error   [-+]#
1h      LOAD    tmp,#x42        B
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/binary
        LOAD    tmp,#x62        b
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/binary
        LOAD    tmp,#x64        D
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/decimal
        LOAD    tmp,#x64        d
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/decimal
        LOAD    tmp,#x6f        O
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/octal
        LOAD    tmp,#x6f        o
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/octal
        LOAD    tmp,#x58        X
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/hex
        LOAD    tmp,#x78        x
        CMPIS?  tmp,r3,tmp
        BRANCH  tmp,@Primitive/read-expression/hex
        TRAP    'syntax-error

Primitive/read-expression/binary
        LOAD    r7,2
        LOAD    r6,0
        ADD     r4,r1,1
        JUMP    @Primitive/read-expression/number/next
Primitive/read-expression/octal
        LOAD    r7,8
        LOAD    r6,0
        ADD     r4,r1,1
        JUMP    @Primitive/read-expression/number/next
Primitive/read-expression/decimal
        LOAD    r7,10
        LOAD    r6,0
        ADD     r4,r1,1
        JUMP    @Primitive/read-expression/number/next

Primitive/read-expression/number
        LOAD    r7,10
        SUB     r6,r3,#x30      0
        LOAD    r5,#f           Negate?
        LOAD    r4,r1
Primitive/read-expression/number/next
        ADD     r1,r1,1
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/source-byte
1h      BRANCH  =acc,@1f        ... unless eof.
2h      CMPEQ?  acc,r1,r4
        BRANCH  =acc,@Primitive/read-expression/number/finish
        TRAP    'syntax-error
1h      PEND    clink,@1f
        JUMP    @Primitive/read-expression/terminator?
1h      BRANCH  acc,@2b
        CMPGE?  tmp,r3,#x30     0
        BRANCH  tmp,@3f         Possibly a digit.
2h      PEND    clink,@1f       Wrong, but how?
        JUMP    @Primitive/read-expression/printable?
1h      BRANCH  acc,@1f
        TRAP    'unprintable
1h      TRAP    'syntax-error
3h      SUB     r3,r3,#x30      0
        CMPLT?  tmp,r3,r7       Small enough?
        BRANCH  tmp,@1f
        ADD     r3,r3,#x30
        JUMP    @2b
1h      MUL     r6,r6,r7
        ADD     r6,r6,r3
        JUMP    @Primitive/read-expression/number/next

Primitive/read-expression/hex
        LOAD    r6,0
        ADD     r1,r1,1
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/source-byte
1h      BRANCH  =acc,@1f
        TRAP    'syntax-error
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/terminator?
1h      BRANCH  =acc,@1f
        TRAP    'syntax-error
Primitive/read-expression/hex/digit
1h      LOAD    tmp,#x66        f
        CMPLE?  acc,r3,tmp
        BRANCH  acc,@1f
        TRAP    'syntax-error
1h      LOAD    acc,#x61        a
        CMPGE?  tmp,r3,acc
        BRANCH  =tmp,@1f
        SUB     r4,r3,acc
        JUMP    @2f

1h      LOAD    tmp,#x46        F
        CMPLE?  tmp,r3,tmp
        BRANCH  tmp,@1f
        TRAP    'syntax-error
1h      LOAD    acc,#x41        A
        CMPGE?  tmp,r3,acc
        BRANCH  tmp,@1f
        SUB     r4,r3,acc
        JUMP    @2f

1h      CMPLE?  tmp,r3,#x39     9
        BRANCH  tmp,@1f
        TRAP    'syntax-error
1h      LOAD    acc,#x30        0; put in the accumulator to match the letters' algorithm.
        CMPGE?  tmp,r3,acc
        BRANCH  tmp,@1f
        TRAP    'syntax-error
2h      MUL     r6,r6,#x10
        SUB     r4,r3,acc
        ADD     r6,r6,r4
        ADD     r1,r1,1
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/source-byte
1h      BRANCH  acc,@Primitive/read-expression/number/finish
        PEND    clink,@1f
        JUMP    @Primitive/read-expression/terminator?
1h      BRANCH  acc,@Primitive/read-expression/number/finish
        JUMP    @Primitive/read-expression/hex/digit

Primitive/read-expression/number/finish
        BRANCH  =r5,@1f         Negate?
        SUB     r6,0,r6
1h      LOAD    acc,r6          Number
        LOAD    r3,'object
        JUMP    @Primitive/read-expression/back-up

Primitive/read-expression/rune
        TRAP    'unimplemented
